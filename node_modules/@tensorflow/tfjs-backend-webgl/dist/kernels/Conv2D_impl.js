/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { broadcast_util, util } from '@tensorflow/tfjs-core';
import { Im2ColPackedProgram } from '../im2col_packed_gpu';
import { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';
import { MatMulPackedProgram } from '../mulmat_packed_gpu';
import * as webgl_util from '../webgl_util';
import { batchMatMulImpl, MATMUL_SHARED_DIM_THRESHOLD } from './BatchMatMul_impl';
import { identity } from './Identity';
import { reshape } from './Reshape';
import { transpose } from './Transpose';
function fitPreluActivationWeightsIntoNhwcFormat(alpha, outputShape, isChannelsLast, backend) {
    // PReLU's activation weights could be a scalar, a 1-D tensor or a 3-D
    // tensor.
    const alphaShape = alpha.shape;
    util.assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `WebGL conv2d only supports scalar, 1-D Tensor or 3-D ` +
        `Tensor PReLU activation weights but got a tensor of ` +
        `rank-${alphaShape.length}.`);
    if (alphaShape.length === 1) {
        const outputChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        util.assert(alphaShape[0] === 1 || alphaShape[0] === outputChannels, () => `WebGL conv2d PReLU activation weights (${alphaShape}) is ` +
            `not compatible with the number of output channels ` +
            `(${outputChannels}).`);
    }
    else if (alphaShape.length === 3) {
        try {
            broadcast_util.assertAndGetBroadcastShape(alphaShape, outputShape);
        }
        catch (e) {
            const errMsg = `WebGL conv2d PReLU activation weights (${alphaShape}) ` +
                `is not compatible with the output shape of the conv2d ` +
                `(${outputShape}).`;
            throw Error(errMsg);
        }
        if (!isChannelsLast) {
            // If PReLU's activation weights is NCHW format, then convert it to NHWC.
            return transpose({ inputs: { x: alpha }, backend, attrs: { perm: [1, 2, 0] } });
        }
    }
    return alpha;
}
// For 1x1 kernels that iterate through every point in the input, convolution
// can be expressed as matrix multiplication (without need for memory
// remapping).
export function conv2dByMatMul({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the
    // result from 2D to 4D.
    const xShape = x.shape;
    const xTexData = backend.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    if (preluActivationWeights != null) {
        const preluActivationWeightsInNhwcFormat = fitPreluActivationWeightsIntoNhwcFormat(preluActivationWeights, convInfo.outShape, isChannelsLast, backend);
        if (preluActivationWeightsInNhwcFormat.dataId !==
            preluActivationWeights.dataId) {
            // preluActivationWeightsInNhwcFormat is a new tensor, temporarily
            // generated to be compatible with the following matmul computation.
            intermediates.push(preluActivationWeightsInNhwcFormat);
            preluActivationWeights = preluActivationWeightsInNhwcFormat;
        }
    }
    // TODO: Once reduction ops are packed, batchMatMul will always be packed
    // and we can remove this condition.
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&
        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
    // The algorithm in the if condition assumes (1) the output will be packed,
    // (2) x is packed, (3) x isChannelsLast, (4)  x's packed texture is already
    // on GPU, (5) col is odd, (6) the width, height and inChannels are the same
    // for xTexData.shape and xShape.
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked &&
        isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 &&
        util.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
        // We avoid expensive packed 2x2 reshape by padding col count to next,
        // even number. When col is odd, the result of packed batchMatMul is
        // the same (has the same texture layout and and values in the texture) as
        // it is for next even col. We make the odd-cols tensor to look like
        // even-cols tensor before the operation and, after the batchMatMul,
        // fix the even-cols result to have odd number of cols.
        const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
        const xReshaped = {
            dataId: x.dataId,
            shape: [1, targetShape, convInfo.inChannels],
            dtype: x.dtype
        };
        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.
        // Decrementing col count, after batchMatMul->...->compileProgram leads to
        // invalid col count within the reference in GPGPUBinary.inShapeInfos.
        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos
        // in compileProgram method, but that would affect compilation of all
        // programs - instead, provide a copy here, with even col count, before
        // calling batchMatMul->...->compileProgram and after that, the original
        // xTexData.shape is restored.
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        util.assert(webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
        const filterReshaped = reshape({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        intermediates.push(filterReshaped);
        const pointwiseConv = batchMatMulImpl({
            a: xReshaped,
            b: filterReshaped,
            backend,
            transposeA,
            transposeB,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
        util.assert(pointwiseConvTexData.isPacked, () => 'batchMatMul result is expected to be packed');
        // Restore the input shape to original.
        xTexData.shape = originalXTexDataShape;
        // Set the output shape - there is no need for expensive reshape as data
        // layout is already correct.
        pointwiseConvTexData.shape = convInfo.outShape;
        out = identity({ inputs: { x: pointwiseConv }, backend });
        out.shape = convInfo.outShape;
        intermediates.push(pointwiseConv);
    }
    else {
        const xInNhwcFormat = isChannelsLast ?
            x :
            transpose({ inputs: { x }, backend, attrs: { perm: [0, 2, 3, 1] } });
        const xInNhwcFormatShape = xInNhwcFormat.shape;
        const targetShape = xInNhwcFormatShape[0] * xInNhwcFormatShape[1] * xInNhwcFormatShape[2];
        const xReshaped = reshape({
            inputs: { x: xInNhwcFormat },
            backend,
            attrs: { shape: [1, targetShape, convInfo.inChannels] }
        });
        const filterReshaped = reshape({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        const result = batchMatMulImpl({
            a: xReshaped,
            b: filterReshaped,
            transposeA,
            transposeB,
            backend,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        const outInNHWCFormatShape = [
            convInfo.batchSize, convInfo.outHeight, convInfo.outWidth,
            convInfo.outChannels
        ];
        const outInNHWCFormat = reshape({ inputs: { x: result }, backend, attrs: { shape: outInNHWCFormatShape } });
        // If the data format is NCHW, then convert the output to be NCHW format.
        out = isChannelsLast ? outInNHWCFormat : transpose({
            inputs: { x: outInNHWCFormat },
            backend,
            attrs: { perm: [0, 3, 1, 2] }
        });
        if (!isChannelsLast) {
            intermediates.push(xInNhwcFormat);
            intermediates.push(outInNHWCFormat);
        }
        intermediates.push(xReshaped);
        intermediates.push(filterReshaped);
        intermediates.push(result);
    }
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
// Implements the im2row algorithm as outlined in "High Performance
// Convolutional Neural Networks for Document Processing" (Suvisoft, 2006)
export function conv2dWithIm2Row({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Rearranges conv2d input so each block to be convolved over forms the
    // column of a new matrix with shape [filterWidth * filterHeight *
    // inChannels, outHeight * outWidth]. The filter is also rearranged so each
    // output channel forms a row of a new matrix with shape [outChannels,
    // filterWidth * filterHeight * inChannels]. The convolution is then
    // computed by multiplying these matrices and reshaping the result.
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === 'channelsLast';
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    if (preluActivationWeights != null) {
        const preluActivationWeightsInNhwcFormat = fitPreluActivationWeightsIntoNhwcFormat(preluActivationWeights, convInfo.outShape, isChannelsLast, backend);
        if (preluActivationWeightsInNhwcFormat.dataId !==
            preluActivationWeights.dataId) {
            // preluActivationWeightsInNhwcFormat is a new tensor, temporarily
            // generated to be compatible with the following matmul computation.
            intermediates.push(preluActivationWeightsInNhwcFormat);
            preluActivationWeights = preluActivationWeightsInNhwcFormat;
        }
    }
    const xSqueezed = reshape({ inputs: { x }, backend, attrs: { shape: x.shape.slice(1) } });
    const w2Row = reshape({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, sharedDim, util.sizeFromShape(filter.shape) / sharedDim] }
    });
    intermediates.push(xSqueezed);
    intermediates.push(w2Row);
    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
    const customValues = [
        xSqueezed.shape, [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth], [convInfo.inChannels],
        [convInfo.filterWidth * convInfo.inChannels], [convInfo.outWidth]
    ];
    const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32', customValues);
    const im2ColReshaped = reshape({
        inputs: { x: im2Col },
        backend,
        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
    });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
    const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [im2ColReshaped, w2Row];
    if (bias) {
        inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');
    const outInNHWCFormatShape = [1, outHeight, outWidth, convInfo.outChannels];
    const outInNHWCFormat = reshape({ inputs: { x: product }, backend, attrs: { shape: outInNHWCFormatShape } });
    // If the data format is NCHW, then convert the output to be NCHW format.
    const out = isChannelsLast ?
        outInNHWCFormat :
        transpose({ inputs: { x: outInNHWCFormat }, backend, attrs: { perm: [0, 3, 1, 2] } });
    if (!isChannelsLast) {
        intermediates.push(outInNHWCFormat);
    }
    intermediates.push(product);
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udjJEX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2tlcm5lbHMvQ29udjJEX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFlLGNBQWMsRUFBYyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUtyRixPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RCxPQUFPLEVBQUMsNEJBQTRCLEVBQUMsTUFBTSxvQ0FBb0MsQ0FBQztBQUNoRixPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RCxPQUFPLEtBQUssVUFBVSxNQUFNLGVBQWUsQ0FBQztBQUU1QyxPQUFPLEVBQUMsZUFBZSxFQUFFLDJCQUEyQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDaEYsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNwQyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2xDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFhdEMsU0FBUyx1Q0FBdUMsQ0FDNUMsS0FBaUIsRUFBRSxXQUE2QyxFQUNoRSxjQUF1QixFQUFFLE9BQXlCO0lBQ3BELHNFQUFzRTtJQUN0RSxVQUFVO0lBQ1YsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUMvQixJQUFJLENBQUMsTUFBTSxDQUNQLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUNqRCxHQUFHLEVBQUUsQ0FBQyx1REFBdUQ7UUFDekQsc0RBQXNEO1FBQ3RELFFBQVEsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdEMsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFL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QUFPLEVBQUUsS0FBSyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsRUFBQyxDQUFDLENBQUM7SUFDOUUsSUFBSSxDQUFDLGNBQWMsRUFBRTtRQUNuQixhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3JDO0lBRUQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QixLQUFLLE1BQU0sQ0FBQyxJQUFJLGFBQWEsRUFBRTtRQUM3QixPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDMUM7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBicm9hZGNhc3RfdXRpbCwgVGVuc29ySW5mbywgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuLy8gaW1wb3J0IHthc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZX0gZnJvbVxuLy8gJy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL2Jyb2FkY2FzdF91dGlsJztcbmltcG9ydCB7TWF0aEJhY2tlbmRXZWJHTH0gZnJvbSAnLi4vYmFja2VuZF93ZWJnbCc7XG5pbXBvcnQge0ltMkNvbFBhY2tlZFByb2dyYW19IGZyb20gJy4uL2ltMmNvbF9wYWNrZWRfZ3B1JztcbmltcG9ydCB7bWFwQWN0aXZhdGlvblRvU2hhZGVyUHJvZ3JhbX0gZnJvbSAnLi4va2VybmVsX3V0aWxzL2tlcm5lbF9mdW5jc191dGlscyc7XG5pbXBvcnQge01hdE11bFBhY2tlZFByb2dyYW19IGZyb20gJy4uL211bG1hdF9wYWNrZWRfZ3B1JztcbmltcG9ydCAqIGFzIHdlYmdsX3V0aWwgZnJvbSAnLi4vd2ViZ2xfdXRpbCc7XG5cbmltcG9ydCB7YmF0Y2hNYXRNdWxJbXBsLCBNQVRNVUxfU0hBUkVEX0RJTV9USFJFU0hPTER9IGZyb20gJy4vQmF0Y2hNYXRNdWxfaW1wbCc7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tICcuL0lkZW50aXR5JztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi9SZXNoYXBlJztcbmltcG9ydCB7dHJhbnNwb3NlfSBmcm9tICcuL1RyYW5zcG9zZSc7XG5cbnR5cGUgQ29udjJEQ29uZmlnID0ge1xuICB4OiBUZW5zb3JJbmZvLFxuICBmaWx0ZXI6IFRlbnNvckluZm8sXG4gIGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbyxcbiAgYmFja2VuZDogTWF0aEJhY2tlbmRXZWJHTCxcbiAgYmlhcz86IFRlbnNvckluZm8sXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHM/OiBUZW5zb3JJbmZvLFxuICBsZWFreXJlbHVBbHBoYT86IG51bWJlcixcbiAgYWN0aXZhdGlvbj86IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uXG59O1xuXG5mdW5jdGlvbiBmaXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzSW50b05od2NGb3JtYXQoXG4gICAgYWxwaGE6IFRlbnNvckluZm8sIG91dHB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbiwgYmFja2VuZDogTWF0aEJhY2tlbmRXZWJHTCkge1xuICAvLyBQUmVMVSdzIGFjdGl2YXRpb24gd2VpZ2h0cyBjb3VsZCBiZSBhIHNjYWxhciwgYSAxLUQgdGVuc29yIG9yIGEgMy1EXG4gIC8vIHRlbnNvci5cbiAgY29uc3QgYWxwaGFTaGFwZSA9IGFscGhhLnNoYXBlO1xuICB1dGlsLmFzc2VydChcbiAgICAgIGFscGhhU2hhcGUubGVuZ3RoIDw9IDEgfHwgYWxwaGFTaGFwZS5sZW5ndGggPT09IDMsXG4gICAgICAoKSA9PiBgV2ViR0wgY29udjJkIG9ubHkgc3VwcG9ydHMgc2NhbGFyLCAxLUQgVGVuc29yIG9yIDMtRCBgICtcbiAgICAgICAgICBgVGVuc29yIFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyBidXQgZ290IGEgdGVuc29yIG9mIGAgK1xuICAgICAgICAgIGByYW5rLSR7YWxwaGFTaGFwZS5sZW5ndGh9LmApO1xuICBpZiAoYWxwaGFTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYWxwaGFTaGFwZVswXSA9PT0gMSB8fCBhbHBoYVNoYXBlWzBdID09PSBvdXRwdXRDaGFubmVscyxcbiAgICAgICAgKCkgPT4gYFdlYkdMIGNvbnYyZCBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHMgKCR7YWxwaGFTaGFwZX0pIGlzIGAgK1xuICAgICAgICAgICAgYG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgYCArXG4gICAgICAgICAgICBgKCR7b3V0cHV0Q2hhbm5lbHN9KS5gKTtcbiAgfSBlbHNlIGlmIChhbHBoYVNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIHRyeSB7XG4gICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhbHBoYVNoYXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYFdlYkdMIGNvbnYyZCBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHMgKCR7YWxwaGFTaGFwZX0pIGAgK1xuICAgICAgICAgIGBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBvdXRwdXQgc2hhcGUgb2YgdGhlIGNvbnYyZCBgICtcbiAgICAgICAgICBgKCR7b3V0cHV0U2hhcGV9KS5gO1xuICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG4gICAgaWYgKCFpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgLy8gSWYgUFJlTFUncyBhY3RpdmF0aW9uIHdlaWdodHMgaXMgTkNIVyBmb3JtYXQsIHRoZW4gY29udmVydCBpdCB0byBOSFdDLlxuICAgICAgcmV0dXJuIHRyYW5zcG9zZSh7aW5wdXRzOiB7eDogYWxwaGF9LCBiYWNrZW5kLCBhdHRyczoge3Blcm06IFsxLCAyLCAwXX19KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFscGhhO1xufVxuXG4vLyBGb3IgMXgxIGtlcm5lbHMgdGhhdCBpdGVyYXRlIHRocm91Z2ggZXZlcnkgcG9pbnQgaW4gdGhlIGlucHV0LCBjb252b2x1dGlvblxuLy8gY2FuIGJlIGV4cHJlc3NlZCBhcyBtYXRyaXggbXVsdGlwbGljYXRpb24gKHdpdGhvdXQgbmVlZCBmb3IgbWVtb3J5XG4vLyByZW1hcHBpbmcpLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbnYyZEJ5TWF0TXVsKHtcbiAgeCxcbiAgZmlsdGVyLFxuICBjb252SW5mbyxcbiAgYmFja2VuZCxcbiAgYmlhcyA9IG51bGwsXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBudWxsLFxuICBsZWFreXJlbHVBbHBoYSA9IDAsXG4gIGFjdGl2YXRpb24gPSBudWxsXG59OiBDb252MkRDb25maWcpIHtcbiAgLy8gUmVzaGFwZXMgY29udjJEIGlucHV0IHRvIDJEIHRlbnNvcnMsIHVzZXMgbWF0TXVsIGFuZCB0aGVuIHJlc2hhcGUgdGhlXG4gIC8vIHJlc3VsdCBmcm9tIDJEIHRvIDRELlxuICBjb25zdCB4U2hhcGUgPSB4LnNoYXBlO1xuICBjb25zdCB4VGV4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQoeC5kYXRhSWQpO1xuICBjb25zdCBzaGFyZWRNYXRNdWxEaW0gPSBjb252SW5mby5pbkNoYW5uZWxzO1xuICBjb25zdCBvdXRlclNoYXBlWCA9IHhTaGFwZVswXSAqIHhTaGFwZVsxXSAqIHhTaGFwZVsyXTtcbiAgY29uc3Qgb3V0ZXJTaGFwZUZpbHRlciA9IGNvbnZJbmZvLm91dENoYW5uZWxzO1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGNvbnZJbmZvLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnO1xuICBjb25zdCB0cmFuc3Bvc2VBID0gZmFsc2U7XG4gIGNvbnN0IHRyYW5zcG9zZUIgPSBmYWxzZTtcblxuICBsZXQgb3V0OiBUZW5zb3JJbmZvO1xuICBjb25zdCBpbnRlcm1lZGlhdGVzOiBUZW5zb3JJbmZvW10gPSBbXTtcblxuICBpZiAocHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0luTmh3Y0Zvcm1hdCA9XG4gICAgICAgIGZpdFByZWx1QWN0aXZhdGlvbldlaWdodHNJbnRvTmh3Y0Zvcm1hdChcbiAgICAgICAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMsIGNvbnZJbmZvLm91dFNoYXBlLCBpc0NoYW5uZWxzTGFzdCwgYmFja2VuZCk7XG5cbiAgICBpZiAocHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0luTmh3Y0Zvcm1hdC5kYXRhSWQgIT09XG4gICAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMuZGF0YUlkKSB7XG4gICAgICAvLyBwcmVsdUFjdGl2YXRpb25XZWlnaHRzSW5OaHdjRm9ybWF0IGlzIGEgbmV3IHRlbnNvciwgdGVtcG9yYXJpbHlcbiAgICAgIC8vIGdlbmVyYXRlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGZvbGxvd2luZyBtYXRtdWwgY29tcHV0YXRpb24uXG4gICAgICBpbnRlcm1lZGlhdGVzLnB1c2gocHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0luTmh3Y0Zvcm1hdCk7XG4gICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0luTmh3Y0Zvcm1hdDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBPbmNlIHJlZHVjdGlvbiBvcHMgYXJlIHBhY2tlZCwgYmF0Y2hNYXRNdWwgd2lsbCBhbHdheXMgYmUgcGFja2VkXG4gIC8vIGFuZCB3ZSBjYW4gcmVtb3ZlIHRoaXMgY29uZGl0aW9uLlxuICBjb25zdCBiYXRjaE1hdE11bFdpbGxCZVVucGFja2VkID1cbiAgICAgIChvdXRlclNoYXBlWCA9PT0gMSB8fCBvdXRlclNoYXBlRmlsdGVyID09PSAxKSAmJlxuICAgICAgc2hhcmVkTWF0TXVsRGltID4gTUFUTVVMX1NIQVJFRF9ESU1fVEhSRVNIT0xEO1xuXG4gIC8vIFRoZSBhbGdvcml0aG0gaW4gdGhlIGlmIGNvbmRpdGlvbiBhc3N1bWVzICgxKSB0aGUgb3V0cHV0IHdpbGwgYmUgcGFja2VkLFxuICAvLyAoMikgeCBpcyBwYWNrZWQsICgzKSB4IGlzQ2hhbm5lbHNMYXN0LCAoNCkgIHgncyBwYWNrZWQgdGV4dHVyZSBpcyBhbHJlYWR5XG4gIC8vIG9uIEdQVSwgKDUpIGNvbCBpcyBvZGQsICg2KSB0aGUgd2lkdGgsIGhlaWdodCBhbmQgaW5DaGFubmVscyBhcmUgdGhlIHNhbWVcbiAgLy8gZm9yIHhUZXhEYXRhLnNoYXBlIGFuZCB4U2hhcGUuXG4gIGNvbnN0IGNhbk9wdGltaXplID0gIWJhdGNoTWF0TXVsV2lsbEJlVW5wYWNrZWQgJiYgeFRleERhdGEuaXNQYWNrZWQgJiZcbiAgICAgIGlzQ2hhbm5lbHNMYXN0ICYmIHhUZXhEYXRhLnRleHR1cmUgIT0gbnVsbCAmJiB4U2hhcGVbMl0gJSAyICE9PSAwICYmXG4gICAgICB1dGlsLmFycmF5c0VxdWFsKHhUZXhEYXRhLnNoYXBlLnNsaWNlKC0zKSwgeFNoYXBlLnNsaWNlKC0zKSk7XG5cbiAgaWYgKGNhbk9wdGltaXplKSB7XG4gICAgLy8gV2UgYXZvaWQgZXhwZW5zaXZlIHBhY2tlZCAyeDIgcmVzaGFwZSBieSBwYWRkaW5nIGNvbCBjb3VudCB0byBuZXh0LFxuICAgIC8vIGV2ZW4gbnVtYmVyLiBXaGVuIGNvbCBpcyBvZGQsIHRoZSByZXN1bHQgb2YgcGFja2VkIGJhdGNoTWF0TXVsIGlzXG4gICAgLy8gdGhlIHNhbWUgKGhhcyB0aGUgc2FtZSB0ZXh0dXJlIGxheW91dCBhbmQgYW5kIHZhbHVlcyBpbiB0aGUgdGV4dHVyZSkgYXNcbiAgICAvLyBpdCBpcyBmb3IgbmV4dCBldmVuIGNvbC4gV2UgbWFrZSB0aGUgb2RkLWNvbHMgdGVuc29yIHRvIGxvb2sgbGlrZVxuICAgIC8vIGV2ZW4tY29scyB0ZW5zb3IgYmVmb3JlIHRoZSBvcGVyYXRpb24gYW5kLCBhZnRlciB0aGUgYmF0Y2hNYXRNdWwsXG4gICAgLy8gZml4IHRoZSBldmVuLWNvbHMgcmVzdWx0IHRvIGhhdmUgb2RkIG51bWJlciBvZiBjb2xzLlxuICAgIGNvbnN0IHRhcmdldFNoYXBlID0geFNoYXBlWzBdICogeFNoYXBlWzFdICogKHhTaGFwZVsyXSArIDEpO1xuICAgIGNvbnN0IHhSZXNoYXBlZDogVGVuc29ySW5mbyA9IHtcbiAgICAgIGRhdGFJZDogeC5kYXRhSWQsXG4gICAgICBzaGFwZTogWzEsIHRhcmdldFNoYXBlLCBjb252SW5mby5pbkNoYW5uZWxzXSxcbiAgICAgIGR0eXBlOiB4LmR0eXBlXG4gICAgfTtcbiAgICAvLyB4VGV4RGF0YS5zaGFwZSBnZXRzIHJlZmVyZW5jZWQgZnJvbSBHUEdQVUJpbmFyeS5pblNoYXBlSW5mb3MuXG4gICAgLy8gRGVjcmVtZW50aW5nIGNvbCBjb3VudCwgYWZ0ZXIgYmF0Y2hNYXRNdWwtPi4uLi0+Y29tcGlsZVByb2dyYW0gbGVhZHMgdG9cbiAgICAvLyBpbnZhbGlkIGNvbCBjb3VudCB3aXRoaW4gdGhlIHJlZmVyZW5jZSBpbiBHUEdQVUJpbmFyeS5pblNoYXBlSW5mb3MuXG4gICAgLy8gQWx0ZXJuYXRpdmUgZml4IHdvdWxkIGJlIHRvIHByb3ZpZGUgYSBjb3B5IHRvIEdQR1BVQmluYXJ5LmluU2hhcGVJbmZvc1xuICAgIC8vIGluIGNvbXBpbGVQcm9ncmFtIG1ldGhvZCwgYnV0IHRoYXQgd291bGQgYWZmZWN0IGNvbXBpbGF0aW9uIG9mIGFsbFxuICAgIC8vIHByb2dyYW1zIC0gaW5zdGVhZCwgcHJvdmlkZSBhIGNvcHkgaGVyZSwgd2l0aCBldmVuIGNvbCBjb3VudCwgYmVmb3JlXG4gICAgLy8gY2FsbGluZyBiYXRjaE1hdE11bC0+Li4uLT5jb21waWxlUHJvZ3JhbSBhbmQgYWZ0ZXIgdGhhdCwgdGhlIG9yaWdpbmFsXG4gICAgLy8geFRleERhdGEuc2hhcGUgaXMgcmVzdG9yZWQuXG4gICAgY29uc3Qgb3JpZ2luYWxYVGV4RGF0YVNoYXBlID0geFRleERhdGEuc2hhcGU7XG4gICAgeFRleERhdGEuc2hhcGUgPSB4VGV4RGF0YS5zaGFwZS5zbGljZSgpO1xuICAgIHhUZXhEYXRhLnNoYXBlW3hUZXhEYXRhLnNoYXBlLmxlbmd0aCAtIDJdKys7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHdlYmdsX3V0aWwuaXNSZXNoYXBlRnJlZSh4VGV4RGF0YS5zaGFwZSwgeFJlc2hhcGVkLnNoYXBlKSxcbiAgICAgICAgKCkgPT4gYHBhY2tlZCByZXNoYXBlICR7eFRleERhdGEuc2hhcGV9IHRvICR7XG4gICAgICAgICAgICB4UmVzaGFwZWQuc2hhcGV9IGlzbid0IGZyZWVgKTtcbiAgICBjb25zdCBmaWx0ZXJSZXNoYXBlZCA9IHJlc2hhcGUoe1xuICAgICAgaW5wdXRzOiB7eDogZmlsdGVyfSxcbiAgICAgIGJhY2tlbmQsXG4gICAgICBhdHRyczoge3NoYXBlOiBbMSwgY29udkluZm8uaW5DaGFubmVscywgY29udkluZm8ub3V0Q2hhbm5lbHNdfVxuICAgIH0pO1xuICAgIGludGVybWVkaWF0ZXMucHVzaChmaWx0ZXJSZXNoYXBlZCk7XG4gICAgY29uc3QgcG9pbnR3aXNlQ29udiA9IGJhdGNoTWF0TXVsSW1wbCh7XG4gICAgICBhOiB4UmVzaGFwZWQsXG4gICAgICBiOiBmaWx0ZXJSZXNoYXBlZCxcbiAgICAgIGJhY2tlbmQsXG4gICAgICB0cmFuc3Bvc2VBLFxuICAgICAgdHJhbnNwb3NlQixcbiAgICAgIGJpYXMsXG4gICAgICBhY3RpdmF0aW9uLFxuICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxcbiAgICAgIGxlYWt5cmVsdUFscGhhXG4gICAgfSk7XG5cbiAgICBjb25zdCBwb2ludHdpc2VDb252VGV4RGF0YSA9IGJhY2tlbmQudGV4RGF0YS5nZXQocG9pbnR3aXNlQ29udi5kYXRhSWQpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBwb2ludHdpc2VDb252VGV4RGF0YS5pc1BhY2tlZCxcbiAgICAgICAgKCkgPT4gJ2JhdGNoTWF0TXVsIHJlc3VsdCBpcyBleHBlY3RlZCB0byBiZSBwYWNrZWQnKTtcbiAgICAvLyBSZXN0b3JlIHRoZSBpbnB1dCBzaGFwZSB0byBvcmlnaW5hbC5cbiAgICB4VGV4RGF0YS5zaGFwZSA9IG9yaWdpbmFsWFRleERhdGFTaGFwZTtcbiAgICAvLyBTZXQgdGhlIG91dHB1dCBzaGFwZSAtIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGV4cGVuc2l2ZSByZXNoYXBlIGFzIGRhdGFcbiAgICAvLyBsYXlvdXQgaXMgYWxyZWFkeSBjb3JyZWN0LlxuICAgIHBvaW50d2lzZUNvbnZUZXhEYXRhLnNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG5cbiAgICBvdXQgPSBpZGVudGl0eSh7aW5wdXRzOiB7eDogcG9pbnR3aXNlQ29udn0sIGJhY2tlbmR9KTtcbiAgICBvdXQuc2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcblxuICAgIGludGVybWVkaWF0ZXMucHVzaChwb2ludHdpc2VDb252KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB4SW5OaHdjRm9ybWF0ID0gaXNDaGFubmVsc0xhc3QgP1xuICAgICAgICB4IDpcbiAgICAgICAgdHJhbnNwb3NlKHtpbnB1dHM6IHt4fSwgYmFja2VuZCwgYXR0cnM6IHtwZXJtOiBbMCwgMiwgMywgMV19fSk7XG4gICAgY29uc3QgeEluTmh3Y0Zvcm1hdFNoYXBlID0geEluTmh3Y0Zvcm1hdC5zaGFwZTtcbiAgICBjb25zdCB0YXJnZXRTaGFwZSA9XG4gICAgICAgIHhJbk5od2NGb3JtYXRTaGFwZVswXSAqIHhJbk5od2NGb3JtYXRTaGFwZVsxXSAqIHhJbk5od2NGb3JtYXRTaGFwZVsyXTtcbiAgICBjb25zdCB4UmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICAgIGlucHV0czoge3g6IHhJbk5od2NGb3JtYXR9LFxuICAgICAgYmFja2VuZCxcbiAgICAgIGF0dHJzOiB7c2hhcGU6IFsxLCB0YXJnZXRTaGFwZSwgY29udkluZm8uaW5DaGFubmVsc119XG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyUmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICAgIGlucHV0czoge3g6IGZpbHRlcn0sXG4gICAgICBiYWNrZW5kLFxuICAgICAgYXR0cnM6IHtzaGFwZTogWzEsIGNvbnZJbmZvLmluQ2hhbm5lbHMsIGNvbnZJbmZvLm91dENoYW5uZWxzXX1cbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBiYXRjaE1hdE11bEltcGwoe1xuICAgICAgYTogeFJlc2hhcGVkLFxuICAgICAgYjogZmlsdGVyUmVzaGFwZWQsXG4gICAgICB0cmFuc3Bvc2VBLFxuICAgICAgdHJhbnNwb3NlQixcbiAgICAgIGJhY2tlbmQsXG4gICAgICBiaWFzLFxuICAgICAgYWN0aXZhdGlvbixcbiAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gICAgICBsZWFreXJlbHVBbHBoYVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0SW5OSFdDRm9ybWF0U2hhcGUgPSBbXG4gICAgICBjb252SW5mby5iYXRjaFNpemUsIGNvbnZJbmZvLm91dEhlaWdodCwgY29udkluZm8ub3V0V2lkdGgsXG4gICAgICBjb252SW5mby5vdXRDaGFubmVsc1xuICAgIF07XG4gICAgY29uc3Qgb3V0SW5OSFdDRm9ybWF0ID0gcmVzaGFwZShcbiAgICAgICAge2lucHV0czoge3g6IHJlc3VsdH0sIGJhY2tlbmQsIGF0dHJzOiB7c2hhcGU6IG91dEluTkhXQ0Zvcm1hdFNoYXBlfX0pO1xuXG4gICAgLy8gSWYgdGhlIGRhdGEgZm9ybWF0IGlzIE5DSFcsIHRoZW4gY29udmVydCB0aGUgb3V0cHV0IHRvIGJlIE5DSFcgZm9ybWF0LlxuICAgIG91dCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0SW5OSFdDRm9ybWF0IDogdHJhbnNwb3NlKHtcbiAgICAgIGlucHV0czoge3g6IG91dEluTkhXQ0Zvcm1hdH0sXG4gICAgICBiYWNrZW5kLFxuICAgICAgYXR0cnM6IHtwZXJtOiBbMCwgMywgMSwgMl19XG4gICAgfSk7XG4gICAgaWYgKCFpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKHhJbk5od2NGb3JtYXQpO1xuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKG91dEluTkhXQ0Zvcm1hdCk7XG4gICAgfVxuXG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKGZpbHRlclJlc2hhcGVkKTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2gocmVzdWx0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaSBvZiBpbnRlcm1lZGlhdGVzKSB7XG4gICAgYmFja2VuZC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIEltcGxlbWVudHMgdGhlIGltMnJvdyBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW4gXCJIaWdoIFBlcmZvcm1hbmNlXG4vLyBDb252b2x1dGlvbmFsIE5ldXJhbCBOZXR3b3JrcyBmb3IgRG9jdW1lbnQgUHJvY2Vzc2luZ1wiIChTdXZpc29mdCwgMjAwNilcbmV4cG9ydCBmdW5jdGlvbiBjb252MmRXaXRoSW0yUm93KHtcbiAgeCxcbiAgZmlsdGVyLFxuICBjb252SW5mbyxcbiAgYmFja2VuZCxcbiAgYmlhcyA9IG51bGwsXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBudWxsLFxuICBsZWFreXJlbHVBbHBoYSA9IDAsXG4gIGFjdGl2YXRpb24gPSBudWxsXG59OiBDb252MkRDb25maWcpIHtcbiAgLy8gUmVhcnJhbmdlcyBjb252MmQgaW5wdXQgc28gZWFjaCBibG9jayB0byBiZSBjb252b2x2ZWQgb3ZlciBmb3JtcyB0aGVcbiAgLy8gY29sdW1uIG9mIGEgbmV3IG1hdHJpeCB3aXRoIHNoYXBlIFtmaWx0ZXJXaWR0aCAqIGZpbHRlckhlaWdodCAqXG4gIC8vIGluQ2hhbm5lbHMsIG91dEhlaWdodCAqIG91dFdpZHRoXS4gVGhlIGZpbHRlciBpcyBhbHNvIHJlYXJyYW5nZWQgc28gZWFjaFxuICAvLyBvdXRwdXQgY2hhbm5lbCBmb3JtcyBhIHJvdyBvZiBhIG5ldyBtYXRyaXggd2l0aCBzaGFwZSBbb3V0Q2hhbm5lbHMsXG4gIC8vIGZpbHRlcldpZHRoICogZmlsdGVySGVpZ2h0ICogaW5DaGFubmVsc10uIFRoZSBjb252b2x1dGlvbiBpcyB0aGVuXG4gIC8vIGNvbXB1dGVkIGJ5IG11bHRpcGx5aW5nIHRoZXNlIG1hdHJpY2VzIGFuZCByZXNoYXBpbmcgdGhlIHJlc3VsdC5cbiAgY29uc3Qge1xuICAgIGZpbHRlcldpZHRoLFxuICAgIGZpbHRlckhlaWdodCxcbiAgICBpbkNoYW5uZWxzLFxuICAgIG91dFdpZHRoLFxuICAgIG91dEhlaWdodCxcbiAgICBkYXRhRm9ybWF0XG4gIH0gPSBjb252SW5mbztcblxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnO1xuXG4gIGNvbnN0IHNoYXJlZERpbSA9IGZpbHRlcldpZHRoICogZmlsdGVySGVpZ2h0ICogaW5DaGFubmVscztcbiAgY29uc3QgbnVtQ29scyA9IG91dEhlaWdodCAqIG91dFdpZHRoO1xuICBjb25zdCB4MkNvbFNoYXBlID0gW3NoYXJlZERpbSwgbnVtQ29sc107XG4gIGNvbnN0IHRyYW5zcG9zZUEgPSB0cnVlO1xuICBjb25zdCB0cmFuc3Bvc2VCID0gZmFsc2U7XG5cbiAgY29uc3QgaW50ZXJtZWRpYXRlczogVGVuc29ySW5mb1tdID0gW107XG5cbiAgaWYgKHByZWx1QWN0aXZhdGlvbldlaWdodHMgIT0gbnVsbCkge1xuICAgIGNvbnN0IHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQgPVxuICAgICAgICBmaXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzSW50b05od2NGb3JtYXQoXG4gICAgICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBjb252SW5mby5vdXRTaGFwZSwgaXNDaGFubmVsc0xhc3QsIGJhY2tlbmQpO1xuXG4gICAgaWYgKHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQuZGF0YUlkICE9PVxuICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLmRhdGFJZCkge1xuICAgICAgLy8gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0luTmh3Y0Zvcm1hdCBpcyBhIG5ldyB0ZW5zb3IsIHRlbXBvcmFyaWx5XG4gICAgICAvLyBnZW5lcmF0ZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBmb2xsb3dpbmcgbWF0bXVsIGNvbXB1dGF0aW9uLlxuICAgICAgaW50ZXJtZWRpYXRlcy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQpO1xuICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeFNxdWVlemVkID1cbiAgICAgIHJlc2hhcGUoe2lucHV0czoge3h9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlOiB4LnNoYXBlLnNsaWNlKDEpfX0pO1xuICBjb25zdCB3MlJvdyA9IHJlc2hhcGUoe1xuICAgIGlucHV0czoge3g6IGZpbHRlcn0sXG4gICAgYmFja2VuZCxcbiAgICBhdHRyczoge3NoYXBlOiBbMSwgc2hhcmVkRGltLCB1dGlsLnNpemVGcm9tU2hhcGUoZmlsdGVyLnNoYXBlKSAvIHNoYXJlZERpbV19XG4gIH0pO1xuXG4gIGludGVybWVkaWF0ZXMucHVzaCh4U3F1ZWV6ZWQpO1xuICBpbnRlcm1lZGlhdGVzLnB1c2godzJSb3cpO1xuXG4gIGNvbnN0IGltMkNvbFByb2dyYW0gPSBuZXcgSW0yQ29sUGFja2VkUHJvZ3JhbSh4MkNvbFNoYXBlLCBjb252SW5mbyk7XG4gIGNvbnN0IGN1c3RvbVZhbHVlcyA9IFtcbiAgICB4U3F1ZWV6ZWQuc2hhcGUsIFtjb252SW5mby5wYWRJbmZvLnRvcCwgY29udkluZm8ucGFkSW5mby5sZWZ0XSxcbiAgICBbY29udkluZm8uc3RyaWRlSGVpZ2h0LCBjb252SW5mby5zdHJpZGVXaWR0aF0sXG4gICAgW2NvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0LCBjb252SW5mby5kaWxhdGlvbldpZHRoXSwgW2NvbnZJbmZvLmluQ2hhbm5lbHNdLFxuICAgIFtjb252SW5mby5maWx0ZXJXaWR0aCAqIGNvbnZJbmZvLmluQ2hhbm5lbHNdLCBbY29udkluZm8ub3V0V2lkdGhdXG4gIF07XG4gIGNvbnN0IGltMkNvbCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKFxuICAgICAgaW0yQ29sUHJvZ3JhbSwgW3hTcXVlZXplZF0sICdmbG9hdDMyJywgY3VzdG9tVmFsdWVzKTtcbiAgY29uc3QgaW0yQ29sUmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICBpbnB1dHM6IHt4OiBpbTJDb2x9LFxuICAgIGJhY2tlbmQsXG4gICAgYXR0cnM6IHtzaGFwZTogWzEsIHgyQ29sU2hhcGVbMF0sIHgyQ29sU2hhcGVbMV1dfVxuICB9KTtcblxuICBpbnRlcm1lZGlhdGVzLnB1c2goaW0yQ29sKTtcbiAgaW50ZXJtZWRpYXRlcy5wdXNoKGltMkNvbFJlc2hhcGVkKTtcblxuICBjb25zdCBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICBjb25zdCBoYXNMZWFreXJlbHVBbHBoYSA9IGFjdGl2YXRpb24gPT09ICdsZWFreXJlbHUnO1xuICBjb25zdCBmdXNlZEFjdGl2YXRpb24gPVxuICAgICAgYWN0aXZhdGlvbiA/IG1hcEFjdGl2YXRpb25Ub1NoYWRlclByb2dyYW0oYWN0aXZhdGlvbiwgdHJ1ZSkgOiBudWxsO1xuICBjb25zdCBtYXRtdWxQcm9ncmFtID0gbmV3IE1hdE11bFBhY2tlZFByb2dyYW0oXG4gICAgICBpbTJDb2xSZXNoYXBlZC5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICB3MlJvdy5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICBbMSwgbnVtQ29scywgY29udkluZm8ub3V0Q2hhbm5lbHNdLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCLCBoYXNCaWFzLFxuICAgICAgZnVzZWRBY3RpdmF0aW9uLCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBoYXNMZWFreXJlbHVBbHBoYSk7XG4gIGNvbnN0IGlucHV0czogVGVuc29ySW5mb1tdID0gW2ltMkNvbFJlc2hhcGVkLCB3MlJvd107XG4gIGlmIChiaWFzKSB7XG4gICAgaW5wdXRzLnB1c2goYmlhcyk7XG4gIH1cbiAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICBpbnB1dHMucHVzaChwcmVsdUFjdGl2YXRpb25XZWlnaHRzKTtcbiAgfVxuICBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICBjb25zdCAkbGVha3lyZWx1QWxwaGEgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFxuICAgICAgICBbXSwgJ2Zsb2F0MzInLFxuICAgICAgICB1dGlsLmNyZWF0ZVNjYWxhclZhbHVlKGxlYWt5cmVsdUFscGhhIGFzIHt9IGFzICdmbG9hdDMyJywgJ2Zsb2F0MzInKSk7XG4gICAgaW5wdXRzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgfVxuICBjb25zdCBwcm9kdWN0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0obWF0bXVsUHJvZ3JhbSwgaW5wdXRzLCAnZmxvYXQzMicpO1xuXG4gIGNvbnN0IG91dEluTkhXQ0Zvcm1hdFNoYXBlID0gWzEsIG91dEhlaWdodCwgb3V0V2lkdGgsIGNvbnZJbmZvLm91dENoYW5uZWxzXTtcbiAgY29uc3Qgb3V0SW5OSFdDRm9ybWF0ID0gcmVzaGFwZShcbiAgICAgIHtpbnB1dHM6IHt4OiBwcm9kdWN0fSwgYmFja2VuZCwgYXR0cnM6IHtzaGFwZTogb3V0SW5OSFdDRm9ybWF0U2hhcGV9fSk7XG5cbiAgLy8gSWYgdGhlIGRhdGEgZm9ybWF0IGlzIE5DSFcsIHRoZW4gY29udmVydCB0aGUgb3V0cHV0IHRvIGJlIE5DSFcgZm9ybWF0LlxuICBjb25zdCBvdXQgPSBpc0NoYW5uZWxzTGFzdCA/XG4gICAgICBvdXRJbk5IV0NGb3JtYXQgOlxuICAgICAgdHJhbnNwb3NlKFxuICAgICAgICAgIHtpbnB1dHM6IHt4OiBvdXRJbk5IV0NGb3JtYXR9LCBiYWNrZW5kLCBhdHRyczoge3Blcm06IFswLCAzLCAxLCAyXX19KTtcbiAgaWYgKCFpc0NoYW5uZWxzTGFzdCkge1xuICAgIGludGVybWVkaWF0ZXMucHVzaChvdXRJbk5IV0NGb3JtYXQpO1xuICB9XG5cbiAgaW50ZXJtZWRpYXRlcy5wdXNoKHByb2R1Y3QpO1xuICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJtZWRpYXRlcykge1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIl19