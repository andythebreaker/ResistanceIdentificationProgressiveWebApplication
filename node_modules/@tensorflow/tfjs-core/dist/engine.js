/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { KernelBackend } from './backends/backend';
import { Environment, setEnvironmentGlobal } from './environment';
import { getGlobalNamespace } from './global_util';
import { Add, Cast, Identity } from './kernel_names';
import { getGradient, getKernel, getKernelsForBackend } from './kernel_registry';
import * as log from './log';
import { Profiler } from './profiler';
import { backpropagateGradients, getFilteredNodesXToY } from './tape';
import { setTensorTracker, Tensor, Variable } from './tensor';
import { getTensorsInContainer } from './tensor_util';
import * as util from './util';
import { bytesFromStringArray, makeOnesTypedArray, now, sizeFromShape } from './util';
function isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
}
class EngineState {
    constructor() {
        // Public since optimizers will use it.
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numStringTensors = 0;
        this.numDataBuffers = 0;
        // Number of nested tf.grad() statements when computing higher-order
        // gradients. E.g. `1` for first-order gradients and `2` for second-order
        // gradients. Used to track if the tape should be removed after a backprop.
        this.gradientDepth = 0;
        // Number of nested kernel calls. When kernel depth is greater than 1, we turn
        // off the tape.
        this.kernelDepth = 0;
        this.scopeStack = [];
        /**
         * Keeps track of the number of data moves during a kernel execution. We
         * maintain a stack since kernels can call other kernels, recursively.
         */
        this.numDataMovesStack = [];
        this.nextScopeId = 0;
        this.tensorInfo = new WeakMap();
        this.profiling = false;
        this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null,
            get kernelNames() {
                return Array.from(new Set(this.kernels.map(k => k.name)));
            }
        };
    }
    dispose() {
        for (const variableName in this.registeredVariables) {
            this.registeredVariables[variableName].dispose();
        }
    }
}
export class Engine {
    constructor(ENV) {
        this.ENV = ENV;
        this.registry = {};
        this.registryFactory = {};
        this.pendingBackendInitId = 0;
        this.state = new EngineState();
    }
    async ready() {
        if (this.pendingBackendInit != null) {
            return this.pendingBackendInit.then(() => { });
        }
        if (this.backendInstance != null) {
            return;
        }
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
            const backendName = sortedBackends[i];
            const success = await this.initializeBackend(backendName).success;
            if (success) {
                await this.setBackend(backendName);
                return;
            }
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` +
            `failed.`);
    }
    get backend() {
        if (this.pendingBackendInit != null) {
            throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` +
                `sure to await tf.ready() or await tf.setBackend() before calling ` +
                `other methods`);
        }
        if (this.backendInstance == null) {
            const { name, asyncInit } = this.initializeBackendsAndReturnBest();
            if (asyncInit) {
                throw new Error(`The highest priority backend '${name}' has not yet been ` +
                    `initialized. Make sure to await tf.ready() or ` +
                    `await tf.setBackend() before calling other methods`);
            }
            this.setBackend(name);
        }
        return this.backendInstance;
    }
    backendNames() {
        return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
        if (!(backendName in this.registry)) {
            // If the backend hasn't been initialized but we have a registry entry for
            // it, initialize it and return it.
            if (backendName in this.registryFactory) {
                const { asyncInit } = this.initializeBackend(backendName);
                if (asyncInit) {
                    // Backend is not ready yet.
                    return null;
                }
            }
            else {
                return null;
            }
        }
        return this.registry[backendName];
    }
    findBackendFactory(backendName) {
        if (!(backendName in this.registryFactory)) {
            return null;
        }
        return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
        if (backendName in this.registryFactory) {
            log.warn(`${backendName} backend was already registered. ` +
                `Reusing existing backend factory.`);
            return false;
        }
        this.registryFactory[backendName] = { factory, priority };
        return true;
    }
    async setBackend(backendName) {
        if (this.registryFactory[backendName] == null) {
            throw new Error(`Backend name '${backendName}' not found in registry`);
        }
        this.backendName = backendName;
        if (this.registry[backendName] == null) {
            this.backendInstance = null;
            const { success, asyncInit } = this.initializeBackend(backendName);
            const result = asyncInit ? await success : success;
            if (!result) {
                return false;
            }
        }
        this.backendInstance = this.registry[backendName];
        this.setupRegisteredKernels();
        // Reset the profiler.
        this.profiler = new Profiler(this.backendInstance);
        return true;
    }
    setupRegisteredKernels() {
        const kernels = getKernelsForBackend(this.backendName);
        kernels.forEach(kernel => {
            if (kernel.setupFunc != null) {
                kernel.setupFunc(this.backendInstance);
            }
        });
    }
    disposeRegisteredKernels(backendName) {
        const kernels = getKernelsForBackend(backendName);
        kernels.forEach(kernel => {
            if (kernel.disposeFunc != null) {
                kernel.disposeFunc(this.registry[backendName]);
            }
        });
    }
    /**
     * Initializes a backend by looking up the backend name in the factory
     * registry and calling the factory method. Returns a boolean representing
     * whether the initialization of the backend suceeded. Throws an error if
     * there is no backend in the factory registry.
     */
    initializeBackend(backendName) {
        const registryFactoryEntry = this.registryFactory[backendName];
        if (registryFactoryEntry == null) {
            throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
        }
        try {
            const backend = registryFactoryEntry.factory();
            /* Test if the factory returns a promise.
            Done in a more liberal way than
            previous 'Promise.resolve(backend)===backend'
            as we needed to account for custom Promise
            implementations (e.g. Angular) */
            if (backend && !(backend instanceof KernelBackend) &&
                typeof backend.then === 'function') {
                const promiseId = ++this.pendingBackendInitId;
                const success = backend
                    .then(backendInstance => {
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) {
                        return false;
                    }
                    this.registry[backendName] = backendInstance;
                    this.pendingBackendInit = null;
                    return true;
                })
                    .catch(err => {
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) {
                        return false;
                    }
                    this.pendingBackendInit = null;
                    log.warn(`Initialization of backend ${backendName} failed`);
                    log.warn(err.stack || err.message);
                    return false;
                });
                this.pendingBackendInit = success;
                return { success, asyncInit: true };
            }
            else {
                this.registry[backendName] = backend;
                return { success: true, asyncInit: false };
            }
        }
        catch (err) {
            log.warn(`Initialization of backend ${backendName} failed`);
            log.warn(err.stack || err.message);
            return { success: false, asyncInit: false };
        }
    }
    removeBackend(backendName) {
        if (!(backendName in this.registryFactory)) {
            throw new Error(`${backendName} backend not found in registry`);
        }
        if (this.backendName === backendName && this.pendingBackendInit != null) {
            // There is a pending promise of the backend we want to remove. Make it
            // obsolete.
            this.pendingBackendInitId++;
        }
        if (backendName in this.registry) {
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        delete this.registryFactory[backendName];
        // Unset the backend if it is active.
        if (this.backendName === backendName) {
            this.pendingBackendInit = null;
            this.backendName = null;
            this.backendInstance = null;
        }
    }
    getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) {
            throw new Error('No backend found in registry.');
        }
        return Object.keys(this.registryFactory).sort((a, b) => {
            // Highest priority comes first.
            return this.registryFactory[b].priority -
                this.registryFactory[a].priority;
        });
    }
    initializeBackendsAndReturnBest() {
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
            const backendName = sortedBackends[i];
            const { success, asyncInit } = this.initializeBackend(backendName);
            if (asyncInit || success) {
                return { name: backendName, asyncInit };
            }
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` +
            `failed.`);
    }
    moveData(backend, dataId) {
        const info = this.state.tensorInfo.get(dataId);
        const srcBackend = info.backend;
        const values = this.readSync(dataId);
        const refCount = srcBackend.refCount(dataId);
        // Delete the tensor from the old backend and move it to the new
        // backend.
        srcBackend.disposeData(dataId, true);
        info.backend = backend;
        backend.move(dataId, values, info.shape, info.dtype, refCount);
        if (this.shouldCheckForMemLeaks()) {
            // Track the number of moves during a kernel execution to correctly
            // detect memory leaks.
            this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        }
    }
    tidy(nameOrFn, fn) {
        let name = null;
        if (fn == null) {
            // Called with only 1 argument.
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to tidy()');
            }
            fn = nameOrFn;
        }
        else {
            // Called with 2 arguments.
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to tidy() must be a function');
            }
            name = nameOrFn;
            // TODO(nsthorat,smilkov): Do operation logging and performance
            // profiling.
        }
        let result;
        return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
            result = fn();
            if (result instanceof Promise) {
                console.error('Cannot return a Promise inside of tidy.');
            }
            return result;
        });
    }
    scopedRun(start, end, f) {
        start();
        try {
            const res = f();
            end();
            return res;
        }
        catch (ex) {
            end();
            throw ex;
        }
    }
    nextTensorId() {
        return Engine.nextTensorId++;
    }
    nextVariableId() {
        return Engine.nextVariableId++;
    }
    /**
     * This method is called instead of the public-facing tensor.clone() when
     * saving a tensor for backwards pass. It makes sure to add the clone
     * operation to the tape regardless of being called inside a kernel
     * execution.
     */
    clone(x) {
        const y = ENGINE.runKernel(Identity, { x });
        const inputs = { x };
        const grad = (dy) => ({
            x: () => {
                const dtype = 'float32';
                const gradInputs = { x: dy };
                const attrs = { dtype };
                return ENGINE.runKernel(Cast, gradInputs, 
                // tslint:disable-next-line: no-unnecessary-type-assertion
                attrs);
            }
        });
        const saved = [];
        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
        return y;
    }
    /**
     * Execute a kernel with the given name and return the output tensor.
     *
     * @param kernelName The name of the kernel to execute.
     * @param inputs A map of input names to tensors.
     * @param attrs A map of attribute names to their values. An attribute is a
     *     primitive (non-tensor) input to the kernel.
     * @param inputsToSave A list of tensors, inputs to save for the backprop
     *     computation.
     * @param outputsToSave A list of booleans, specifying which output to save
     *     for the backprop computation. These are booleans since the output
     * tensors are not visible to the user.
     */
    runKernel(kernelName, inputs, attrs) {
        if (this.backendName == null) {
            // backend has not been initialized yet (backend initialization is lazy
            // can be deferred until an op/ kernel is run).
            // The below getter has side effects that will try to initialize the
            // backend and set properties like this.backendName
            // tslint:disable-next-line: no-unused-expression
            this.backend;
        }
        const hasKernel = getKernel(kernelName, this.backendName) != null;
        if (!hasKernel) {
            throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
        }
        return this.runKernelFunc({ kernelName, inputs, attrs });
    }
    shouldCheckForMemLeaks() {
        return this.ENV.getBool('IS_TEST');
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
        const numDataIdsAfter = this.backend.numDataIds();
        // Count the number of data ids associated with the result of the kernel.
        let numOutputDataIds = 0;
        outInfos.forEach(info => {
            // Complex numbers allocate 3 data ids, one for 'real', one for
            // 'imaginary', and one for the container that holds the former two.
            numOutputDataIds += (info.dtype === 'complex64' ? 3 : 1);
        });
        // Account for the number of moves during kernel execution. A "data move"
        // can happen in the middle of a kernel execution, placing a new (key,value)
        // pair in the data storage. Since data moves have net zero effect (we
        // always remove the data from the old backend), we have to cancel them out
        // when detecting memory leaks.
        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
        if (dataIdsLeaked > 0) {
            throw new Error(`Backend '${this.backendName}' has an internal memory leak ` +
                `(${dataIdsLeaked} data ids) after running '${kernelName}'`);
        }
    }
    /**
     * Internal helper method to execute a kernel Func
     *
     * Use `runKernel` to execute kernels from outside of engine.
     */
    runKernelFunc(kernelParams) {
        let outputs;
        let saved = [];
        const isTapeOn = this.isTapeOn();
        const startingBytecount = this.state.numBytes;
        const startingNumTensors = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) {
            this.state.numDataMovesStack.push(0);
        }
        let kernelFunc;
        if (this.backendName == null) {
            // backend has not been initialized yet (backend initialization is lazy
            // can be deferred until an op/ kernel is run).
            // The below getter has side effects that will try to initialize the
            // backend and set properties like this.backendName
            // tslint:disable-next-line: no-unused-expression
            this.backend;
        }
        let out;
        const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ?
            kernelParams.kernelName :
            this.state.activeScope != null ? this.state.activeScope.name : '';
        // Create the kernelFunc from either a registered kernel OR passed in
        // forward/backward functions (used by custom grad). In this context a
        // kernelFunc wraps a kernel implementation with some bookkeeping.
        if (isRegisteredKernelInvocation(kernelParams)) {
            const { kernelName, inputs, attrs } = kernelParams;
            if (this.backendName == null) {
                // backend has not been initialized yet (backend initialization is lazy
                // can be deferred until an op/ kernel is run).
                // The below getter has side effects that will try to initialize the
                // backend and set properties like this.backendName
                // tslint:disable-next-line: no-unused-expression
                this.backend;
            }
            const kernel = getKernel(kernelName, this.backendName);
            util.assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
            kernelFunc = () => {
                const numDataIdsBefore = this.backend.numDataIds();
                out = kernel.kernelFunc({ inputs, attrs, backend: this.backend });
                const outInfos = Array.isArray(out) ? out : [out];
                if (this.shouldCheckForMemLeaks()) {
                    this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
                }
                const outTensors = outInfos.map((outInfo) => {
                    // todo (yassogba) remove this option (Tensor) when node backend
                    // methods have been modularized and they all return tensorInfo.
                    // TensorInfos do not have a rank attribute.
                    if (outInfo.rank != null) {
                        return outInfo;
                    }
                    return this.makeTensorFromTensorInfo(outInfo);
                });
                // Save any required inputs and outputs.
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since there would be no backprop for these tensors
                // (which would otherwise dispose them).
                if (isTapeOn) {
                    const tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);
                    saved = this.saveTensorsForBackwardMode(tensorsToSave);
                }
                return outTensors;
            };
        }
        else {
            const { forwardFunc } = kernelParams;
            // Running a customGrad op.
            const saveFunc = (tensors) => {
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since we would never run backprop, which disposes
                // the kept tensors.
                if (!isTapeOn) {
                    return;
                }
                saved = tensors.map(tensor => this.keep(this.clone(tensor)));
            };
            kernelFunc = () => {
                const numDataIdsBefore = this.backend.numDataIds();
                out = this.tidy(() => forwardFunc(this.backend, saveFunc));
                const outs = (Array.isArray(out) ? out : [out]);
                if (this.shouldCheckForMemLeaks()) {
                    // Scope name is used to print a more helpful error message if needed.
                    this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
                }
                return outs;
            };
        }
        //
        // Run the kernelFunc. Optionally profiling it.
        //
        const { inputs, attrs } = kernelParams;
        const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ?
            null :
            kernelParams.backwardsFunc;
        let kernelProfile;
        this.scopedRun(
        // Stop recording to a tape when running a kernel.
        () => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
            if (!this.ENV.getBool('DEBUG') && !this.state.profiling) {
                outputs = kernelFunc();
            }
            else {
                kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
                if (this.ENV.getBool('DEBUG')) {
                    this.profiler.logKernelProfile(kernelProfile);
                }
                outputs = kernelProfile.outputs;
            }
        });
        if (isTapeOn) {
            this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
        }
        if (this.state.profiling) {
            this.state.activeProfile.kernels.push({
                name: kernelOrScopeName,
                bytesAdded: this.state.numBytes - startingBytecount,
                totalBytesSnapshot: this.state.numBytes,
                tensorsAdded: this.state.numTensors - startingNumTensors,
                totalTensorsSnapshot: this.state.numTensors,
                inputShapes: Object.keys(inputs).map(key => inputs[key] != null ? inputs[key].shape : null),
                outputShapes: outputs.map(item => item.shape),
                kernelTimeMs: kernelProfile.timeMs,
                extraInfo: kernelProfile.extraInfo
            });
        }
        return (Array.isArray(out) ? outputs : outputs[0]);
    }
    /**
     * Saves tensors used in forward mode for use in backward mode.
     *
     * @param tensors the list of tensors to save.
     */
    saveTensorsForBackwardMode(tensors) {
        const saved = tensors.map(tensor => this.keep(this.clone(tensor)));
        return saved;
    }
    /**
     * Returns a list of tensors to save for a given gradient calculation.
     *
     * @param kernelName name of kernel to look up gradient for.
     * @param inputs a map of input tensors.
     * @param outputs an array of output tensors from forward mode of kernel.
     */
    getTensorsForGradient(kernelName, inputs, outputs) {
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
            const inputsToSave = gradConfig.inputsToSave || [];
            const outputsToSave = gradConfig.outputsToSave || [];
            // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs
            // specified in inputsToSave will be saved.
            let inputTensorsToSave;
            if (gradConfig.saveAllInputs) {
                util.assert(Array.isArray(inputs), () => 'saveAllInputs is true, expected inputs to be an array.');
                inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
            }
            else {
                inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
            }
            const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
            return inputTensorsToSave.concat(outputTensorsToSave);
        }
        // We return an empty list rather than throw an error because the kernel we
        // are looking up may not actually be relevant to backproping through the
        // overall function
        //
        // See 'does not error if irrelevant (pruned) ops are missing grads' test
        // in gradients_test.ts for an example.
        return [];
    }
    /**
     * Internal method used by public APIs for tensor creation. Makes a new
     * tensor with the provided shape, dtype and values. It always
     * creates a new data id and writes the values to the underlying backend.
     */
    makeTensor(values, shape, dtype, backend) {
        if (values == null) {
            throw new Error('Values passed to engine.makeTensor() are null');
        }
        dtype = dtype || 'float32';
        backend = backend || this.backend;
        let backendVals = values;
        if (dtype === 'string' && util.isString(values[0])) {
            backendVals = values.map(d => util.encodeString(d));
        }
        const dataId = backend.write(backendVals, shape, dtype);
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        // Count bytes for string tensors.
        if (dtype === 'string') {
            const info = this.state.tensorInfo.get(dataId);
            const newBytes = bytesFromStringArray(backendVals);
            this.state.numBytes += newBytes - info.bytes;
            info.bytes = newBytes;
        }
        return t;
    }
    /**
     * Internal method used by backends. Makes a new tensor that is a wrapper
     * around an existing data id in TensorInfo. It doesn't create a new data id,
     * only increments the ref count used in memory tracking.
     */
    makeTensorFromTensorInfo(tensorInfo, backend) {
        const { dataId, shape, dtype } = tensorInfo;
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        return t;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
        name = name || this.nextVariableId().toString();
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.cast(dtype);
        }
        const v = new Variable(initialValue, trainable, name, this.nextTensorId());
        if (this.state.registeredVariables[v.name] != null) {
            throw new Error(`Variable with name ${v.name} was already registered`);
        }
        this.state.registeredVariables[v.name] = v;
        this.incRef(v, this.backend);
        return v;
    }
    trackTensor(a, backend) {
        this.state.numTensors++;
        if (a.dtype === 'string') {
            this.state.numStringTensors++;
        }
        // Bytes for complex numbers are counted by their components. Bytes for
        // string tensors are counted when writing values.
        let bytes = 0;
        if (a.dtype !== 'complex64' && a.dtype !== 'string') {
            bytes = a.size * util.bytesPerElement(a.dtype);
        }
        this.state.numBytes += bytes;
        if (!this.state.tensorInfo.has(a.dataId)) {
            this.state.numDataBuffers++;
            this.state.tensorInfo.set(a.dataId, {
                backend: backend || this.backend,
                dtype: a.dtype,
                shape: a.shape,
                bytes
            });
        }
        if (!(a instanceof Variable)) {
            this.track(a);
        }
    }
    // Track the tensor by dataId and increase the refCount for the dataId in the
    // backend.
    // TODO(pyu10055): This is currently used by makeVariable method, to increase
    // refCount on the backend for the dataId. It can potentially be replaced with
    // Identity op indead of calling backend directly.
    incRef(a, backend) {
        this.trackTensor(a, backend);
        this.backend.incRef(a.dataId);
    }
    removeDataId(dataId, backend) {
        if (this.state.tensorInfo.has(dataId) &&
            this.state.tensorInfo.get(dataId).backend === backend) {
            this.state.tensorInfo.delete(dataId);
            this.state.numDataBuffers--;
        }
    }
    disposeTensor(a) {
        if (!this.state.tensorInfo.has(a.dataId)) {
            return;
        }
        const info = this.state.tensorInfo.get(a.dataId);
        this.state.numTensors--;
        if (a.dtype === 'string') {
            this.state.numStringTensors--;
            this.state.numBytes -= info.bytes;
        }
        // Don't count bytes for complex numbers as they are counted by their
        // components.
        if (a.dtype !== 'complex64' && a.dtype !== 'string') {
            const bytes = a.size * util.bytesPerElement(a.dtype);
            this.state.numBytes -= bytes;
        }
        // Remove the reference to dataId if backend dispose the data successfully
        if (info.backend.disposeData(a.dataId)) {
            this.removeDataId(a.dataId, info.backend);
        }
        // TODO(nsthorat): Construct an error and save the stack trace for
        // debugging when in debug mode. Creating a stack trace is too expensive
        // to do unconditionally.
    }
    disposeVariables() {
        for (const varName in this.state.registeredVariables) {
            const v = this.state.registeredVariables[varName];
            this.disposeVariable(v);
        }
    }
    disposeVariable(v) {
        this.disposeTensor(v);
        if (this.state.registeredVariables[v.name] != null) {
            delete this.state.registeredVariables[v.name];
        }
    }
    memory() {
        const info = this.backend.memory();
        info.numTensors = this.state.numTensors;
        info.numDataBuffers = this.state.numDataBuffers;
        info.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
            info.unreliable = true;
            if (info.reasons == null) {
                info.reasons = [];
            }
            info.reasons.push('Memory usage by string tensors is approximate ' +
                '(2 bytes per character)');
        }
        return info;
    }
    async profile(query) {
        this.state.profiling = true;
        const startBytes = this.state.numBytes;
        const startNumTensors = this.state.numTensors;
        this.state.activeProfile.kernels = [];
        this.state.activeProfile.result = await query();
        this.state.profiling = false;
        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(d => d.totalBytesSnapshot));
        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
        this.state.activeProfile.newTensors =
            this.state.numTensors - startNumTensors;
        for (const kernel of this.state.activeProfile.kernels) {
            kernel.kernelTimeMs = await kernel.kernelTimeMs;
            kernel.extraInfo = await kernel.extraInfo;
        }
        return this.state.activeProfile;
    }
    isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
        const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
            gradientsFunc = gradConfig.gradFunc;
        }
        if (gradientsFunc != null) {
            tapeNode.gradient = (dys) => {
                // TODO(smilkov): To optimize back-prop, pass dys that are not used in
                // the backprop graph to the user as null instead of zeros
                dys = dys.map((dy, i) => {
                    if (dy == null) {
                        const output = outputs[i];
                        const vals = util.makeZerosTypedArray(output.size, output.dtype);
                        return this.makeTensor(vals, output.shape, output.dtype);
                    }
                    return dy;
                });
                // Grad functions of ops with single outputs expect a dy, while ops
                // with multiple outputs expect dys (array of dy).
                return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
            };
        }
        this.state.activeTape.push(tapeNode);
    }
    keep(result) {
        result.kept = true;
        return result;
    }
    startTape() {
        if (this.state.gradientDepth === 0) {
            this.state.activeTape = [];
        }
        this.state.gradientDepth++;
    }
    endTape() {
        this.state.gradientDepth--;
    }
    /**
     * Start a scope. Use this with endScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    startScope(name) {
        const scopeInfo = {
            track: [],
            name: 'unnamed scope',
            id: this.state.nextScopeId++
        };
        if (name) {
            scopeInfo.name = name;
        }
        this.state.scopeStack.push(scopeInfo);
        this.state.activeScope = scopeInfo;
    }
    /**
     * End a scope. Use this with startScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    endScope(result) {
        const tensorsToTrackInParent = getTensorsInContainer(result);
        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(t => t.id));
        // Dispose the arrays tracked in this scope.
        for (let i = 0; i < this.state.activeScope.track.length; i++) {
            const tensor = this.state.activeScope.track[i];
            if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {
                tensor.dispose();
            }
        }
        const oldScope = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ?
            null :
            this.state.scopeStack[this.state.scopeStack.length - 1];
        // Track the current result in the parent scope.
        tensorsToTrackInParent.forEach(tensor => {
            // Only track the tensor if was allocated in the inner scope and is not
            // globally kept.
            if (!tensor.kept && tensor.scopeId === oldScope.id) {
                this.track(tensor);
            }
        });
    }
    /**
     * Returns gradients of `f` with respect to each of the `xs`. The gradients
     * returned are of the same length as `xs`, but some might be null if `f`
     * was not a function of that `x`. It also takes optional dy to multiply the
     * gradient, which defaults to `1`.
     */
    gradients(f, xs, dy, allowNoGradients = false) {
        util.assert(xs.length > 0, () => 'gradients() received an empty list of xs.');
        if (dy != null && dy.dtype !== 'float32') {
            throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
        }
        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy('forward', f));
        util.assert(y instanceof Tensor, () => 'The result y returned by f() must be a tensor.');
        // Filter out the nodes that don't connect x => y.
        const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
            throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                'that the f you passed encloses all operations that lead from x ' +
                'to y.');
        }
        return this.tidy('backward', () => {
            const accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ones(y.shape) : dy;
            // Backprop gradients through the filtered nodes.
            backpropagateGradients(accumulatedGradientMap, filteredTape, 
            // Pass the tidy function to avoid circular dep with `tape.ts`.
            f => this.tidy(f), 
            // Pass an add function to avoide a circular dep with `tape.ts`.
            add);
            const grads = xs.map(x => accumulatedGradientMap[x.id]);
            if (this.state.gradientDepth === 0) {
                // This means that we are not computing higher-order gradients
                // and can clean up the tape.
                this.state.activeTape.forEach(node => {
                    for (const tensor of node.saved) {
                        tensor.dispose();
                    }
                });
                this.state.activeTape = null;
            }
            return { value: y, grads };
        });
    }
    customGrad(f) {
        util.assert(util.isFunction(f), () => 'The f passed in customGrad(f) must be a function.');
        return (...inputs) => {
            util.assert(inputs.every(t => t instanceof Tensor), () => 'The args passed in customGrad(f)(x1, x2,...) must all be ' +
                'tensors');
            let res;
            const inputMap = {};
            inputs.forEach((input, i) => {
                inputMap[i] = input;
            });
            const forwardFunc = (_, save) => {
                res = f(...[...inputs, save]);
                util.assert(res.value instanceof Tensor, () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.value` is a tensor');
                util.assert(util.isFunction(res.gradFunc), () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function.');
                return res.value;
            };
            const backwardsFunc = (dy, saved) => {
                const gradRes = res.gradFunc(dy, saved);
                const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
                util.assert(grads.length === inputs.length, () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function that returns ' +
                    'the same number of tensors as inputs passed to f(...).');
                util.assert(grads.every(t => t instanceof Tensor), () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function that returns ' +
                    'a list of only tensors.');
                const gradMap = {};
                grads.forEach((grad, i) => {
                    gradMap[i] = () => grad;
                });
                return gradMap;
            };
            return this.runKernelFunc({
                forwardFunc,
                backwardsFunc,
                inputs: inputMap,
            });
        };
    }
    readSync(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
    }
    read(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.read(dataId);
    }
    readToGPU(dataId, options) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readToGPU(dataId, options);
    }
    async time(query) {
        const start = now();
        const timingInfo = await this.backend.time(query);
        timingInfo.wallMs = now() - start;
        return timingInfo;
    }
    /**
     * Tracks a Tensor in the current scope to be automatically cleaned up
     * when the current scope ends, and returns the value.
     *
     * @param result The Tensor to track in the current scope.
     */
    track(result) {
        if (this.state.activeScope != null) {
            result.scopeId = this.state.activeScope.id;
            this.state.activeScope.track.push(result);
        }
        return result;
    }
    get registeredVariables() {
        return this.state.registeredVariables;
    }
    /**
     * Resets the engine state. Removes all backends but does not remove
     * registered backend factories.
     */
    reset() {
        // Make any pending promise obsolete.
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new EngineState();
        for (const backendName in this.registry) {
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
    }
}
Engine.nextTensorId = 0;
Engine.nextVariableId = 0;
function ones(shape) {
    const values = makeOnesTypedArray(sizeFromShape(shape), 'float32');
    return ENGINE.makeTensor(values, shape, 'float32');
}
export function getOrMakeEngine() {
    const ns = getGlobalNamespace();
    if (ns._tfengine == null) {
        const environment = new Environment(ns);
        ns._tfengine = new Engine(environment);
    }
    setEnvironmentGlobal(ns._tfengine.ENV);
    // Tell the current tensor interface that the global engine is responsible
    // for tracking.
    setTensorTracker(() => ns._tfengine);
    return ns._tfengine;
}
export const ENGINE = getOrMakeEngine();
/**
 * A implementation of the add op for use within engine and tape.
 *
 * This allows us to avoid a circular dependency between add.ts and engine.
 * It is exported to be available in tape tests.
 */
export function add(a, b) {
    // We duplicate Add here to avoid a circular dependency with add.ts.
    const inputs = { a, b };
    return ENGINE.runKernel(Add, inputs);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5naW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9lbmdpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUErQixhQUFhLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRSxPQUFPLEVBQUMsV0FBVyxFQUFFLG9CQUFvQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNqRCxPQUFPLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBRSxvQkFBb0IsRUFBcUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNuSCxPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUM3QixPQUFPLEVBQWdCLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuRCxPQUFPLEVBQUMsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQVcsTUFBTSxRQUFRLENBQUM7QUFDOUUsT0FBTyxFQUFvQyxnQkFBZ0IsRUFBRSxNQUFNLEVBQWlCLFFBQVEsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUU5RyxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFcEQsT0FBTyxLQUFLLElBQUksTUFBTSxRQUFRLENBQUM7QUFDL0IsT0FBTyxFQUFDLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUMsTUFBTSxRQUFRLENBQUM7QUF1RXBGLFNBQVMsNEJBQTRCLENBRWpDLGdCQUNnQztJQUVsQyxPQUFRLGdCQUFrRCxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUM7QUFDaEYsQ0FBQztBQUVELE1BQU0sV0FBVztJQUFqQjtRQUNFLHVDQUF1QztRQUN2Qyx3QkFBbUIs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QUM3RCxJQUFJLEVBQUUsQ0FBQyxTQUFTLElBQUksSUFBSSxFQUFFO1FBQ3hCLE1BQU0sV0FBVyxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3hDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDeEM7SUFDRCxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXZDLDBFQUEwRTtJQUMxRSxnQkFBZ0I7SUFDaEIsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JDLE9BQU8sRUFBRSxDQUFDLFNBQVMsQ0FBQztBQUN0QixDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sTUFBTSxHQUFHLGVBQWUsRUFBRSxDQUFDO0FBRXhDOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBUztJQUN0QyxvRUFBb0U7SUFDcEUsTUFBTSxNQUFNLEdBQUcsRUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUM7SUFDdEIsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxNQUE4QixDQUFDLENBQUM7QUFDL0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtCYWNrZW5kVGltaW5nSW5mbywgRGF0YU1vdmVyLCBLZXJuZWxCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmRzL2JhY2tlbmQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgc2V0RW52aXJvbm1lbnRHbG9iYWx9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHtnZXRHbG9iYWxOYW1lc3BhY2V9IGZyb20gJy4vZ2xvYmFsX3V0aWwnO1xuaW1wb3J0IHtBZGQsIENhc3QsIElkZW50aXR5fSBmcm9tICcuL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge2dldEdyYWRpZW50LCBnZXRLZXJuZWwsIGdldEtlcm5lbHNGb3JCYWNrZW5kLCBHcmFkRnVuYywgTmFtZWRBdHRyTWFwLCBUZW5zb3JJbmZvfSBmcm9tICcuL2tlcm5lbF9yZWdpc3RyeSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnLi9sb2cnO1xuaW1wb3J0IHtLZXJuZWxQcm9maWxlLCBQcm9maWxlcn0gZnJvbSAnLi9wcm9maWxlcic7XG5pbXBvcnQge2JhY2twcm9wYWdhdGVHcmFkaWVudHMsIGdldEZpbHRlcmVkTm9kZXNYVG9ZLCBUYXBlTm9kZX0gZnJvbSAnLi90YXBlJztcbmltcG9ydCB7RGF0YUlkLCBEYXRhVG9HUFVPcHRpb25zLCBHUFVEYXRhLCBzZXRUZW5zb3JUcmFja2VyLCBUZW5zb3IsIFRlbnNvclRyYWNrZXIsIFZhcmlhYmxlfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQge0dyYWRTYXZlRnVuYywgTmFtZWRUZW5zb3JNYXAsIE5hbWVkVmFyaWFibGVNYXAsIFRlbnNvckNvbnRhaW5lcn0gZnJvbSAnLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtnZXRUZW5zb3JzSW5Db250YWluZXJ9IGZyb20gJy4vdGVuc29yX3V0aWwnO1xuaW1wb3J0IHtCYWNrZW5kVmFsdWVzLCBEYXRhVHlwZSwgRGF0YVZhbHVlc30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge2J5dGVzRnJvbVN0cmluZ0FycmF5LCBtYWtlT25lc1R5cGVkQXJyYXksIG5vdywgc2l6ZUZyb21TaGFwZX0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYW4gb3V0cHV0LiBUaGUgc2F2ZSBmdW5jdGlvbiBpcyBmb3Igc2F2aW5nIHRlbnNvcnNcbiAqIGNvbXB1dGVkIGluIHRoZSBmb3J3YXJkIHBhc3MsIHRoYXQgd2UgbmVlZCBpbiB0aGUgYmFja3dhcmQgcGFzcy5cbiAqL1xuZXhwb3J0IHR5cGUgRm9yd2FyZEZ1bmM8VD4gPSAoYmFja2VuZDogS2VybmVsQmFja2VuZCwgc2F2ZT86IEdyYWRTYXZlRnVuYykgPT4gVDtcblxuLyoqXG4gKiBAZG9jYWxpYXMgKGE6IFRlbnNvciwgYjogVGVuc29yLC4uLiwgc2F2ZT86IEZ1bmN0aW9uKSA9PiB7XG4gKiAgIHZhbHVlOiBUZW5zb3IsXG4gKiAgIGdyYWRGdW5jOiAoZHk6IFRlbnNvciwgc2F2ZWQ/OiBOYW1lZFRlbnNvck1hcCkgPT4gVGVuc29yIHwgVGVuc29yW11cbiAqIH1cbiAqL1xuZXhwb3J0IHR5cGUgQ3VzdG9tR3JhZGllbnRGdW5jPFQgZXh0ZW5kcyBUZW5zb3I+ID1cbiAgICAoLi4uaW5wdXRzOiBBcnJheTxUZW5zb3J8R3JhZFNhdmVGdW5jPikgPT4ge1xuICAgICAgdmFsdWU6IFQ7XG4gICAgICBncmFkRnVuYzogKGR5OiBULCBzYXZlZDogVGVuc29yW10pID0+IFRlbnNvciB8IFRlbnNvcltdO1xuICAgIH07XG5cbmV4cG9ydCB0eXBlIE1lbW9yeUluZm8gPSB7XG4gIG51bVRlbnNvcnM6IG51bWJlcjsgbnVtRGF0YUJ1ZmZlcnM6IG51bWJlcjsgbnVtQnl0ZXM6IG51bWJlcjtcbiAgdW5yZWxpYWJsZT86IGJvb2xlYW47IHJlYXNvbnM6IHN0cmluZ1tdO1xufTtcblxudHlwZSBLZXJuZWxJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7IGJ5dGVzQWRkZWQ6IG51bWJlcjsgdG90YWxCeXRlc1NuYXBzaG90OiBudW1iZXI7XG4gIHRlbnNvcnNBZGRlZDogbnVtYmVyO1xuICB0b3RhbFRlbnNvcnNTbmFwc2hvdDogbnVtYmVyO1xuICBpbnB1dFNoYXBlczogbnVtYmVyW11bXTtcbiAgb3V0cHV0U2hhcGVzOiBudW1iZXJbXVtdO1xuICBrZXJuZWxUaW1lTXM6IG51bWJlciB8IHtlcnJvcjogc3RyaW5nfSB8IFByb21pc2U8bnVtYmVyfHtlcnJvcjogc3RyaW5nfT47XG4gIGV4dHJhSW5mbzogc3RyaW5nIHwgUHJvbWlzZTxzdHJpbmc+O1xufTtcblxuZXhwb3J0IHR5cGUgUHJvZmlsZUluZm8gPSB7XG4gIG5ld0J5dGVzOiBudW1iZXI7IG5ld1RlbnNvcnM6IG51bWJlcjsgcGVha0J5dGVzOiBudW1iZXI7XG4gIGtlcm5lbHM6IEtlcm5lbEluZm9bXTtcbiAgcmVzdWx0OiBUZW5zb3JDb250YWluZXI7XG4gIGtlcm5lbE5hbWVzOiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltaW5nSW5mbyBleHRlbmRzIEJhY2tlbmRUaW1pbmdJbmZvIHtcbiAgd2FsbE1zOiBudW1iZXI7XG59XG5cbi8qKiBAZG9jYWxpYXMgRnVuY3Rpb24gKi9cbmV4cG9ydCB0eXBlIFNjb3BlRm48VCBleHRlbmRzIFRlbnNvckNvbnRhaW5lcj4gPSAoKSA9PiBUO1xuXG5pbnRlcmZhY2UgU2NvcGVTdGF0ZSB7XG4gIHRyYWNrOiBUZW5zb3JbXTtcbiAgbmFtZTogc3RyaW5nO1xuICBpZDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUmVnaXN0ZXJlZEtlcm5lbEludm9jYXRpb248SSBleHRlbmRzIE5hbWVkVGVuc29yTWFwPiB7XG4gIGtlcm5lbE5hbWU6IHN0cmluZztcbiAgaW5wdXRzOiBJO1xuICBhdHRycz86IE5hbWVkQXR0ck1hcDtcbn1cblxuaW50ZXJmYWNlIEN1c3RvbUdyYWRLZXJuZWxJbnZvY2F0aW9uPFQgZXh0ZW5kcyBUZW5zb3J8VGVuc29yW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEkgZXh0ZW5kcyBOYW1lZFRlbnNvck1hcD4ge1xuICBmb3J3YXJkRnVuYzogRm9yd2FyZEZ1bmM8VD47XG4gIGJhY2t3YXJkc0Z1bmM6IChkeTogVCwgc2F2ZWQ6IFRlbnNvcltdKSA9PiB7XG4gICAgW1AgaW4ga2V5b2YgSV06ICgpID0+IElbUF1cbiAgfTtcbiAgaW5wdXRzOiBJO1xuICBhdHRycz86IE5hbWVkQXR0ck1hcDtcbn1cblxuZnVuY3Rpb24gaXNSZWdpc3RlcmVkS2VybmVsSW52b2NhdGlvbjxUIGV4dGVuZHMgVGVuc29yfFRlbnNvcltdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSSBleHRlbmRzIE5hbWVkVGVuc29yTWFwPihcbiAgICBrZXJuZWxJbnZvY2F0aW9uOiBSZWdpc3RlcmVkS2VybmVsSW52b2NhdGlvbjxJPnxcbiAgICBDdXN0b21HcmFkS2VybmVsSW52b2NhdGlvbjxULCBJPik6XG4gICAga2VybmVsSW52b2NhdGlvbiBpcyBSZWdpc3RlcmVkS2VybmVsSW52b2NhdGlvbjxJPiB7XG4gIHJldHVybiAoa2VybmVsSW52b2NhdGlvbiBhcyBSZWdpc3RlcmVkS2VybmVsSW52b2NhdGlvbjxJPikua2VybmVsTmFtZSAhPSBudWxsO1xufVxuXG5jbGFzcyBFbmdpbmVTdGF0ZSB7XG4gIC8vIFB1YmxpYyBzaW5jZSBvcHRpbWl6ZXJzIHdpbGwgdXNlIGl0LlxuICByZWdpc3RlcmVkVmFyaWFibGVzOiBOYW1lZFZhcmlhYmxlTWFwID0ge307XG5cbiAgbmV4dFRhcGVOb2RlSWQgPSAwO1xuICBudW1CeXRlcyA9IDA7XG4gIG51bVRlbnNvcnMgPSAwO1xuICBudW1TdHJpbmdUZW5zb3JzID0gMDtcbiAgbnVtRGF0YUJ1ZmZlcnMgPSAwO1xuXG4gIGFjdGl2ZVRhcGU6IFRhcGVOb2RlW107XG4gIC8vIE51bWJlciBvZiBuZXN0ZWQgdGYuZ3JhZCgpIHN0YXRlbWVudHMgd2hlbiBjb21wdXRpbmcgaGlnaGVyLW9yZGVyXG4gIC8vIGdyYWRpZW50cy4gRS5nLiBgMWAgZm9yIGZpcnN0LW9yZGVyIGdyYWRpZW50cyBhbmQgYDJgIGZvciBzZWNvbmQtb3JkZXJcbiAgLy8gZ3JhZGllbnRzLiBVc2VkIHRvIHRyYWNrIGlmIHRoZSB0YXBlIHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGEgYmFja3Byb3AuXG4gIGdyYWRpZW50RGVwdGggPSAwO1xuICAvLyBOdW1iZXIgb2YgbmVzdGVkIGtlcm5lbCBjYWxscy4gV2hlbiBrZXJuZWwgZGVwdGggaXMgZ3JlYXRlciB0aGFuIDEsIHdlIHR1cm5cbiAgLy8gb2ZmIHRoZSB0YXBlLlxuICBrZXJuZWxEZXB0aCA9IDA7XG5cbiAgLy8gS2VlcCBUZW5zb3JzIHRoYXQgcGFyYWxsZWwgdGhlIHRhcGVzLlxuICBhY3RpdmVTY29wZTogU2NvcGVTdGF0ZTtcbiAgc2NvcGVTdGFjazogU2NvcGVTdGF0ZVtdID0gW107XG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGRhdGEgbW92ZXMgZHVyaW5nIGEga2VybmVsIGV4ZWN1dGlvbi4gV2VcbiAgICogbWFpbnRhaW4gYSBzdGFjayBzaW5jZSBrZXJuZWxzIGNhbiBjYWxsIG90aGVyIGtlcm5lbHMsIHJlY3Vyc2l2ZWx5LlxuICAgKi9cbiAgbnVtRGF0YU1vdmVzU3RhY2s6IG51bWJlcltdID0gW107XG4gIG5leHRTY29wZUlkID0gMDtcblxuICB0ZW5zb3JJbmZvID0gbmV3IFdlYWtNYXA8RGF0YUlkLCB7XG4gICAgYmFja2VuZDogS2VybmVsQmFja2VuZCxcbiAgICBieXRlczogbnVtYmVyLFxuICAgIGR0eXBlOiBEYXRhVHlwZSxcbiAgICBzaGFwZTogbnVtYmVyW11cbiAgfT4oKTtcblxuICBwcm9maWxpbmcgPSBmYWxzZTtcbiAgYWN0aXZlUHJvZmlsZTogUHJvZmlsZUluZm8gPSB7XG4gICAgbmV3Qnl0ZXM6IDAsXG4gICAgbmV3VGVuc29yczogMCxcbiAgICBwZWFrQnl0ZXM6IDAsXG4gICAga2VybmVsczogW10sXG4gICAgcmVzdWx0OiBudWxsLFxuICAgIGdldCBrZXJuZWxOYW1lcygpOlxuICAgICAgICBzdHJpbmdbXSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmtlcm5lbHMubWFwKGsgPT4gay5uYW1lKSkpO1xuICAgICAgICB9XG4gIH07XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlTmFtZSBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVuZ2luZSBpbXBsZW1lbnRzIFRlbnNvclRyYWNrZXIsIERhdGFNb3ZlciB7XG4gIHN0YXRlOiBFbmdpbmVTdGF0ZTtcbiAgYmFja2VuZE5hbWU6IHN0cmluZztcbiAgcmVnaXN0cnk6IHtbaWQ6IHN0cmluZ106IEtlcm5lbEJhY2tlbmR9ID0ge307XG4gIHJlZ2lzdHJ5RmFjdG9yeToge1xuICAgIFtpZDogc3RyaW5nXToge1xuICAgICAgZmFjdG9yeTogKCkgPT4gS2VybmVsQmFja2VuZCB8IFByb21pc2U8S2VybmVsQmFja2VuZD4sXG4gICAgICBwcmlvcml0eTogbnVtYmVyXG4gICAgfVxuICB9ID0ge307XG5cbiAgcHJpdmF0ZSBwcm9maWxlcjogUHJvZmlsZXI7XG4gIHByaXZhdGUgYmFja2VuZEluc3RhbmNlOiBLZXJuZWxCYWNrZW5kO1xuICBwcml2YXRlIHBlbmRpbmdCYWNrZW5kSW5pdDogUHJvbWlzZTxib29sZWFuPjtcbiAgcHJpdmF0ZSBwZW5kaW5nQmFja2VuZEluaXRJZCA9IDA7XG5cbiAgY29uc3RydWN0b3IocHVibGljIEVOVjogRW52aXJvbm1lbnQpIHtcbiAgICB0aGlzLnN0YXRlID0gbmV3IEVuZ2luZVN0YXRlKCk7XG4gIH1cblxuICBhc3luYyByZWFkeSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQmFja2VuZEluaXQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0LnRoZW4oKCkgPT4ge30pO1xuICAgIH1cbiAgICBpZiAodGhpcy5iYWNrZW5kSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRCYWNrZW5kcyA9IHRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkQmFja2VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhY2tlbmROYW1lID0gc29ydGVkQmFja2VuZHNbaV07XG4gICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5pbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSkuc3VjY2VzcztcbiAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0QmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBgICtcbiAgICAgICAgYGZhaWxlZC5gKTtcbiAgfVxuXG4gIGdldCBiYWNrZW5kKCk6IEtlcm5lbEJhY2tlbmQge1xuICAgIGlmICh0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJhY2tlbmQgJyR7dGhpcy5iYWNrZW5kTmFtZX0nIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2UgYCArXG4gICAgICAgICAgYHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBvciBhd2FpdCB0Zi5zZXRCYWNrZW5kKCkgYmVmb3JlIGNhbGxpbmcgYCArXG4gICAgICAgICAgYG90aGVyIG1ldGhvZHNgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja2VuZEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtuYW1lLCBhc3luY0luaXR9ID0gdGhpcy5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0KCk7XG4gICAgICBpZiAoYXN5bmNJbml0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgaGlnaGVzdCBwcmlvcml0eSBiYWNrZW5kICcke25hbWV9JyBoYXMgbm90IHlldCBiZWVuIGAgK1xuICAgICAgICAgICAgYGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBvciBgICtcbiAgICAgICAgICAgIGBhd2FpdCB0Zi5zZXRCYWNrZW5kKCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc2ApO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRCYWNrZW5kKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2U7XG4gIH1cblxuICBiYWNrZW5kTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSk7XG4gIH1cblxuICBmaW5kQmFja2VuZChiYWNrZW5kTmFtZTogc3RyaW5nKTogS2VybmVsQmFja2VuZCB7XG4gICAgaWYgKCEoYmFja2VuZE5hbWUgaW4gdGhpcy5yZWdpc3RyeSkpIHtcbiAgICAgIC8vIElmIHRoZSBiYWNrZW5kIGhhc24ndCBiZWVuIGluaXRpYWxpemVkIGJ1dCB3ZSBoYXZlIGEgcmVnaXN0cnkgZW50cnkgZm9yXG4gICAgICAvLyBpdCwgaW5pdGlhbGl6ZSBpdCBhbmQgcmV0dXJuIGl0LlxuICAgICAgaWYgKGJhY2tlbmROYW1lIGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IHthc3luY0luaXR9ID0gdGhpcy5pbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIGlmIChhc3luY0luaXQpIHtcbiAgICAgICAgICAvLyBCYWNrZW5kIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVtiYWNrZW5kTmFtZV07XG4gIH1cblxuICBmaW5kQmFja2VuZEZhY3RvcnkoYmFja2VuZE5hbWU6IHN0cmluZyk6XG4gICAgICAoKSA9PiBLZXJuZWxCYWNrZW5kIHwgUHJvbWlzZTxLZXJuZWxCYWNrZW5kPiB7XG4gICAgaWYgKCEoYmFja2VuZE5hbWUgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnlGYWN0b3J5W2JhY2tlbmROYW1lXS5mYWN0b3J5O1xuICB9XG5cbiAgcmVnaXN0ZXJCYWNrZW5kKFxuICAgICAgYmFja2VuZE5hbWU6IHN0cmluZyxcbiAgICAgIGZhY3Rvcnk6ICgpID0+IEtlcm5lbEJhY2tlbmQgfCBQcm9taXNlPEtlcm5lbEJhY2tlbmQ+LFxuICAgICAgcHJpb3JpdHkgPSAxKTogYm9vbGVhbiB7XG4gICAgaWYgKGJhY2tlbmROYW1lIGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSB7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgICBgJHtiYWNrZW5kTmFtZX0gYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLiBgICtcbiAgICAgICAgICBgUmV1c2luZyBleGlzdGluZyBiYWNrZW5kIGZhY3RvcnkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucmVnaXN0cnlGYWN0b3J5W2JhY2tlbmROYW1lXSA9IHtmYWN0b3J5LCBwcmlvcml0eX07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBzZXRCYWNrZW5kKGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodGhpcy5yZWdpc3RyeUZhY3RvcnlbYmFja2VuZE5hbWVdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja2VuZCBuYW1lICcke2JhY2tlbmROYW1lfScgbm90IGZvdW5kIGluIHJlZ2lzdHJ5YCk7XG4gICAgfVxuICAgIHRoaXMuYmFja2VuZE5hbWUgPSBiYWNrZW5kTmFtZTtcbiAgICBpZiAodGhpcy5yZWdpc3RyeVtiYWNrZW5kTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5iYWNrZW5kSW5zdGFuY2UgPSBudWxsO1xuICAgICAgY29uc3Qge3N1Y2Nlc3MsIGFzeW5jSW5pdH0gPSB0aGlzLmluaXRpYWxpemVCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSW5pdCA/IGF3YWl0IHN1Y2Nlc3MgOiBzdWNjZXNzO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJhY2tlbmRJbnN0YW5jZSA9IHRoaXMucmVnaXN0cnlbYmFja2VuZE5hbWVdO1xuICAgIHRoaXMuc2V0dXBSZWdpc3RlcmVkS2VybmVscygpO1xuICAgIC8vIFJlc2V0IHRoZSBwcm9maWxlci5cbiAgICB0aGlzLnByb2ZpbGVyID0gbmV3IFByb2ZpbGVyKHRoaXMuYmFja2VuZEluc3RhbmNlKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cFJlZ2lzdGVyZWRLZXJuZWxzKCk6IHZvaWQge1xuICAgIGNvbnN0IGtlcm5lbHMgPSBnZXRLZXJuZWxzRm9yQmFja2VuZCh0aGlzLmJhY2tlbmROYW1lKTtcbiAgICBrZXJuZWxzLmZvckVhY2goa2VybmVsID0+IHtcbiAgICAgIGlmIChrZXJuZWwuc2V0dXBGdW5jICE9IG51bGwpIHtcbiAgICAgICAga2VybmVsLnNldHVwRnVuYyh0aGlzLmJhY2tlbmRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyhiYWNrZW5kTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qga2VybmVscyA9IGdldEtlcm5lbHNGb3JCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICBrZXJuZWxzLmZvckVhY2goa2VybmVsID0+IHtcbiAgICAgIGlmIChrZXJuZWwuZGlzcG9zZUZ1bmMgIT0gbnVsbCkge1xuICAgICAgICBrZXJuZWwuZGlzcG9zZUZ1bmModGhpcy5yZWdpc3RyeVtiYWNrZW5kTmFtZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgYmFja2VuZCBieSBsb29raW5nIHVwIHRoZSBiYWNrZW5kIG5hbWUgaW4gdGhlIGZhY3RvcnlcbiAgICogcmVnaXN0cnkgYW5kIGNhbGxpbmcgdGhlIGZhY3RvcnkgbWV0aG9kLiBSZXR1cm5zIGEgYm9vbGVhbiByZXByZXNlbnRpbmdcbiAgICogd2hldGhlciB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGJhY2tlbmQgc3VjZWVkZWQuIFRocm93cyBhbiBlcnJvciBpZlxuICAgKiB0aGVyZSBpcyBubyBiYWNrZW5kIGluIHRoZSBmYWN0b3J5IHJlZ2lzdHJ5LlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZTogc3RyaW5nKTpcbiAgICAgIHtzdWNjZXNzOiBib29sZWFufFByb21pc2U8Ym9vbGVhbj4sIGFzeW5jSW5pdDogYm9vbGVhbn0ge1xuICAgIGNvbnN0IHJlZ2lzdHJ5RmFjdG9yeUVudHJ5ID0gdGhpcy5yZWdpc3RyeUZhY3RvcnlbYmFja2VuZE5hbWVdO1xuICAgIGlmIChyZWdpc3RyeUZhY3RvcnlFbnRyeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBpbml0aWFsaXplIGJhY2tlbmQgJHtiYWNrZW5kTmFtZX0sIG5vIHJlZ2lzdHJhdGlvbiBmb3VuZC5gKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFja2VuZCA9IHJlZ2lzdHJ5RmFjdG9yeUVudHJ5LmZhY3RvcnkoKTtcbiAgICAgIC8qIFRlc3QgaWYgdGhlIGZhY3RvcnkgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICBEb25lIGluIGEgbW9yZSBsaWJlcmFsIHdheSB0aGFuXG4gICAgICBwcmV2aW91cyAnUHJvbWlzZS5yZXNvbHZlKGJhY2tlbmQpPT09YmFja2VuZCdcbiAgICAgIGFzIHdlIG5lZWRlZCB0byBhY2NvdW50IGZvciBjdXN0b20gUHJvbWlzZVxuICAgICAgaW1wbGVtZW50YXRpb25zIChlLmcuIEFuZ3VsYXIpICovXG4gICAgICBpZiAoYmFja2VuZCAmJiAhKGJhY2tlbmQgaW5zdGFuY2VvZiBLZXJuZWxCYWNrZW5kKSAmJlxuICAgICAgICAgIHR5cGVvZiBiYWNrZW5kLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZUlkID0gKyt0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkO1xuICAgICAgICBjb25zdCBzdWNjZXNzID1cbiAgICAgICAgICAgIGJhY2tlbmRcbiAgICAgICAgICAgICAgICAudGhlbihiYWNrZW5kSW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gT3V0ZGF0ZWQgcHJvbWlzZS4gQW5vdGhlciBiYWNrZW5kIHdhcyBzZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VJZCA8IHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RyeVtiYWNrZW5kTmFtZV0gPSBiYWNrZW5kSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gT3V0ZGF0ZWQgcHJvbWlzZS4gQW5vdGhlciBiYWNrZW5kIHdhcyBzZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VJZCA8IHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmFja2VuZEluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYEluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgJHtiYWNrZW5kTmFtZX0gZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgICBsb2cud2FybihlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCA9IHN1Y2Nlc3M7XG4gICAgICAgIHJldHVybiB7c3VjY2VzcywgYXN5bmNJbml0OiB0cnVlfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVnaXN0cnlbYmFja2VuZE5hbWVdID0gYmFja2VuZCBhcyBLZXJuZWxCYWNrZW5kO1xuICAgICAgICByZXR1cm4ge3N1Y2Nlc3M6IHRydWUsIGFzeW5jSW5pdDogZmFsc2V9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYEluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgJHtiYWNrZW5kTmFtZX0gZmFpbGVkYCk7XG4gICAgICBsb2cud2FybihlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtzdWNjZXNzOiBmYWxzZSwgYXN5bmNJbml0OiBmYWxzZX07XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQmFja2VuZChiYWNrZW5kTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCEoYmFja2VuZE5hbWUgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YmFja2VuZE5hbWV9IGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2tlbmROYW1lID09PSBiYWNrZW5kTmFtZSAmJiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCAhPSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBhIHBlbmRpbmcgcHJvbWlzZSBvZiB0aGUgYmFja2VuZCB3ZSB3YW50IHRvIHJlbW92ZS4gTWFrZSBpdFxuICAgICAgLy8gb2Jzb2xldGUuXG4gICAgICB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkKys7XG4gICAgfVxuXG4gICAgaWYgKGJhY2tlbmROYW1lIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgIHRoaXMuZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzKGJhY2tlbmROYW1lKTtcbiAgICAgIHRoaXMucmVnaXN0cnlbYmFja2VuZE5hbWVdLmRpc3Bvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W2JhY2tlbmROYW1lXTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5yZWdpc3RyeUZhY3RvcnlbYmFja2VuZE5hbWVdO1xuXG4gICAgLy8gVW5zZXQgdGhlIGJhY2tlbmQgaWYgaXQgaXMgYWN0aXZlLlxuICAgIGlmICh0aGlzLmJhY2tlbmROYW1lID09PSBiYWNrZW5kTmFtZSkge1xuICAgICAgdGhpcy5wZW5kaW5nQmFja2VuZEluaXQgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZW5kTmFtZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tlbmRJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRTb3J0ZWRCYWNrZW5kcygpOiBzdHJpbmdbXSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4ge1xuICAgICAgLy8gSGlnaGVzdCBwcmlvcml0eSBjb21lcyBmaXJzdC5cbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeVtiXS5wcmlvcml0eSAtXG4gICAgICAgICAgdGhpcy5yZWdpc3RyeUZhY3RvcnlbYV0ucHJpb3JpdHk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVCYWNrZW5kc0FuZFJldHVybkJlc3QoKTpcbiAgICAgIHtuYW1lOiBzdHJpbmcsIGFzeW5jSW5pdDogYm9vbGVhbn0ge1xuICAgIGNvbnN0IHNvcnRlZEJhY2tlbmRzID0gdGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRCYWNrZW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmFja2VuZE5hbWUgPSBzb3J0ZWRCYWNrZW5kc1tpXTtcbiAgICAgIGNvbnN0IHtzdWNjZXNzLCBhc3luY0luaXR9ID0gdGhpcy5pbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICBpZiAoYXN5bmNJbml0IHx8IHN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHtuYW1lOiBiYWNrZW5kTmFtZSwgYXN5bmNJbml0fTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgYCArXG4gICAgICAgIGBmYWlsZWQuYCk7XG4gIH1cblxuICBtb3ZlRGF0YShiYWNrZW5kOiBLZXJuZWxCYWNrZW5kLCBkYXRhSWQ6IERhdGFJZCkge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGRhdGFJZCk7XG4gICAgY29uc3Qgc3JjQmFja2VuZCA9IGluZm8uYmFja2VuZDtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnJlYWRTeW5jKGRhdGFJZCk7XG4gICAgY29uc3QgcmVmQ291bnQgPSBzcmNCYWNrZW5kLnJlZkNvdW50KGRhdGFJZCk7XG4gICAgLy8gRGVsZXRlIHRoZSB0ZW5zb3IgZnJvbSB0aGUgb2xkIGJhY2tlbmQgYW5kIG1vdmUgaXQgdG8gdGhlIG5ld1xuICAgIC8vIGJhY2tlbmQuXG4gICAgc3JjQmFja2VuZC5kaXNwb3NlRGF0YShkYXRhSWQsIHRydWUpO1xuICAgIGluZm8uYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgYmFja2VuZC5tb3ZlKGRhdGFJZCwgdmFsdWVzLCBpbmZvLnNoYXBlLCBpbmZvLmR0eXBlLCByZWZDb3VudCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpKSB7XG4gICAgICAvLyBUcmFjayB0aGUgbnVtYmVyIG9mIG1vdmVzIGR1cmluZyBhIGtlcm5lbCBleGVjdXRpb24gdG8gY29ycmVjdGx5XG4gICAgICAvLyBkZXRlY3QgbWVtb3J5IGxlYWtzLlxuICAgICAgdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aCAtIDFdKys7XG4gICAgfVxuICB9XG5cbiAgdGlkeTxUIGV4dGVuZHMgVGVuc29yQ29udGFpbmVyPihuYW1lT3JGbjogc3RyaW5nfFNjb3BlRm48VD4sIGZuPzogU2NvcGVGbjxUPik6XG4gICAgICBUIHtcbiAgICBsZXQgbmFtZTogc3RyaW5nID0gbnVsbDtcbiAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgLy8gQ2FsbGVkIHdpdGggb25seSAxIGFyZ3VtZW50LlxuICAgICAgaWYgKHR5cGVvZiBuYW1lT3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gdGlkeSgpJyk7XG4gICAgICB9XG4gICAgICBmbiA9IG5hbWVPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWxsZWQgd2l0aCAyIGFyZ3VtZW50cy5cbiAgICAgIGlmICh0eXBlb2YgbmFtZU9yRm4gIT09ICdzdHJpbmcnICYmICEobmFtZU9yRm4gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgJyArXG4gICAgICAgICAgICAndG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1doZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgJyArXG4gICAgICAgICAgICAndG8gdGlkeSgpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG5hbWVPckZuIGFzIHN0cmluZztcbiAgICAgIC8vIFRPRE8obnN0aG9yYXQsc21pbGtvdik6IERvIG9wZXJhdGlvbiBsb2dnaW5nIGFuZCBwZXJmb3JtYW5jZVxuICAgICAgLy8gcHJvZmlsaW5nLlxuICAgIH1cbiAgICBsZXQgcmVzdWx0OiBUO1xuICAgIHJldHVybiB0aGlzLnNjb3BlZFJ1bihcbiAgICAgICAgKCkgPT4gdGhpcy5zdGFydFNjb3BlKG5hbWUpLCAoKSA9PiB0aGlzLmVuZFNjb3BlKHJlc3VsdCksICgpID0+IHtcbiAgICAgICAgICByZXN1bHQgPSBmbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNjb3BlZFJ1bjxUPihzdGFydDogKCkgPT4gdm9pZCwgZW5kOiAoKSA9PiB2b2lkLCBmOiAoKSA9PiBUKTogVCB7XG4gICAgc3RhcnQoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gZigpO1xuICAgICAgZW5kKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBlbmQoKTtcbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG5leHRUZW5zb3JJZCA9IDA7XG4gIHByaXZhdGUgbmV4dFRlbnNvcklkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIEVuZ2luZS5uZXh0VGVuc29ySWQrKztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG5leHRWYXJpYWJsZUlkID0gMDtcbiAgcHJpdmF0ZSBuZXh0VmFyaWFibGVJZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBFbmdpbmUubmV4dFZhcmlhYmxlSWQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW5zdGVhZCBvZiB0aGUgcHVibGljLWZhY2luZyB0ZW5zb3IuY2xvbmUoKSB3aGVuXG4gICAqIHNhdmluZyBhIHRlbnNvciBmb3IgYmFja3dhcmRzIHBhc3MuIEl0IG1ha2VzIHN1cmUgdG8gYWRkIHRoZSBjbG9uZVxuICAgKiBvcGVyYXRpb24gdG8gdGhlIHRhcGUgcmVnYXJkbGVzcyBvZiBiZWluZyBjYWxsZWQgaW5zaWRlIGEga2VybmVsXG4gICAqIGV4ZWN1dGlvbi5cbiAgICovXG4gIHByaXZhdGUgY2xvbmUoeDogVGVuc29yKTogVGVuc29yIHtcbiAgICBjb25zdCB5OiBUZW5zb3IgPSBFTkdJTkUucnVuS2VybmVsKElkZW50aXR5LCB7eH0gYXMge30gYXMgTmFtZWRUZW5zb3JNYXApO1xuICAgIGNvbnN0IGlucHV0cyA9IHt4fTtcbiAgICBjb25zdCBncmFkID0gKGR5OiBUZW5zb3IpID0+ICh7XG4gICAgICB4OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGR0eXBlID0gJ2Zsb2F0MzInO1xuICAgICAgICBjb25zdCBncmFkSW5wdXRzID0ge3g6IGR5fTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSB7ZHR5cGV9O1xuXG4gICAgICAgIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgICAgICAgICAgICAgIENhc3QsIGdyYWRJbnB1dHMgYXMge30gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgIGF0dHJzIGFzIHt9IGFzIE5hbWVkQXR0ck1hcCkgYXMgVGVuc29yO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNhdmVkOiBUZW5zb3JbXSA9IFtdO1xuICAgIHRoaXMuYWRkVGFwZU5vZGUodGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5uYW1lLCBpbnB1dHMsIFt5XSwgZ3JhZCwgc2F2ZWQsIHt9KTtcbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEga2VybmVsIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHJldHVybiB0aGUgb3V0cHV0IHRlbnNvci5cbiAgICpcbiAgICogQHBhcmFtIGtlcm5lbE5hbWUgVGhlIG5hbWUgb2YgdGhlIGtlcm5lbCB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0gaW5wdXRzIEEgbWFwIG9mIGlucHV0IG5hbWVzIHRvIHRlbnNvcnMuXG4gICAqIEBwYXJhbSBhdHRycyBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgdmFsdWVzLiBBbiBhdHRyaWJ1dGUgaXMgYVxuICAgKiAgICAgcHJpbWl0aXZlIChub24tdGVuc29yKSBpbnB1dCB0byB0aGUga2VybmVsLlxuICAgKiBAcGFyYW0gaW5wdXRzVG9TYXZlIEEgbGlzdCBvZiB0ZW5zb3JzLCBpbnB1dHMgdG8gc2F2ZSBmb3IgdGhlIGJhY2twcm9wXG4gICAqICAgICBjb21wdXRhdGlvbi5cbiAgICogQHBhcmFtIG91dHB1dHNUb1NhdmUgQSBsaXN0IG9mIGJvb2xlYW5zLCBzcGVjaWZ5aW5nIHdoaWNoIG91dHB1dCB0byBzYXZlXG4gICAqICAgICBmb3IgdGhlIGJhY2twcm9wIGNvbXB1dGF0aW9uLiBUaGVzZSBhcmUgYm9vbGVhbnMgc2luY2UgdGhlIG91dHB1dFxuICAgKiB0ZW5zb3JzIGFyZSBub3QgdmlzaWJsZSB0byB0aGUgdXNlci5cbiAgICovXG4gIHJ1bktlcm5lbDxUIGV4dGVuZHMgVGVuc29yfFRlbnNvcltdPihcbiAgICAgIGtlcm5lbE5hbWU6IHN0cmluZywgaW5wdXRzOiBOYW1lZFRlbnNvck1hcCwgYXR0cnM/OiBOYW1lZEF0dHJNYXApOiBUIHtcbiAgICBpZiAodGhpcy5iYWNrZW5kTmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBiYWNrZW5kIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQgKGJhY2tlbmQgaW5pdGlhbGl6YXRpb24gaXMgbGF6eVxuICAgICAgLy8gY2FuIGJlIGRlZmVycmVkIHVudGlsIGFuIG9wLyBrZXJuZWwgaXMgcnVuKS5cbiAgICAgIC8vIFRoZSBiZWxvdyBnZXR0ZXIgaGFzIHNpZGUgZWZmZWN0cyB0aGF0IHdpbGwgdHJ5IHRvIGluaXRpYWxpemUgdGhlXG4gICAgICAvLyBiYWNrZW5kIGFuZCBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuYmFja2VuZE5hbWVcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgIHRoaXMuYmFja2VuZDtcbiAgICB9XG4gICAgY29uc3QgaGFzS2VybmVsID0gZ2V0S2VybmVsKGtlcm5lbE5hbWUsIHRoaXMuYmFja2VuZE5hbWUpICE9IG51bGw7XG4gICAgaWYgKCFoYXNLZXJuZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgS2VybmVsICcke2tlcm5lbE5hbWV9JyBub3QgcmVnaXN0ZXJlZCBmb3IgYmFja2VuZCAnJHtcbiAgICAgICAgICB0aGlzLmJhY2tlbmROYW1lfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucnVuS2VybmVsRnVuYyh7a2VybmVsTmFtZSwgaW5wdXRzLCBhdHRyc30pO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRDaGVja0Zvck1lbUxlYWtzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLkVOVi5nZXRCb29sKCdJU19URVNUJyk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrS2VybmVsRm9yTWVtTGVhayhcbiAgICAgIGtlcm5lbE5hbWU6IHN0cmluZywgbnVtRGF0YUlkc0JlZm9yZTogbnVtYmVyLFxuICAgICAgb3V0SW5mb3M6IFRlbnNvckluZm9bXSk6IHZvaWQge1xuICAgIGNvbnN0IG51bURhdGFJZHNBZnRlciA9IHRoaXMuYmFja2VuZC5udW1EYXRhSWRzKCk7XG5cbiAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRhdGEgaWRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBrZXJuZWwuXG4gICAgbGV0IG51bU91dHB1dERhdGFJZHMgPSAwO1xuICAgIG91dEluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAvLyBDb21wbGV4IG51bWJlcnMgYWxsb2NhdGUgMyBkYXRhIGlkcywgb25lIGZvciAncmVhbCcsIG9uZSBmb3JcbiAgICAgIC8vICdpbWFnaW5hcnknLCBhbmQgb25lIGZvciB0aGUgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIGZvcm1lciB0d28uXG4gICAgICBudW1PdXRwdXREYXRhSWRzICs9IChpbmZvLmR0eXBlID09PSAnY29tcGxleDY0JyA/IDMgOiAxKTtcbiAgICB9KTtcblxuICAgIC8vIEFjY291bnQgZm9yIHRoZSBudW1iZXIgb2YgbW92ZXMgZHVyaW5nIGtlcm5lbCBleGVjdXRpb24uIEEgXCJkYXRhIG1vdmVcIlxuICAgIC8vIGNhbiBoYXBwZW4gaW4gdGhlIG1pZGRsZSBvZiBhIGtlcm5lbCBleGVjdXRpb24sIHBsYWNpbmcgYSBuZXcgKGtleSx2YWx1ZSlcbiAgICAvLyBwYWlyIGluIHRoZSBkYXRhIHN0b3JhZ2UuIFNpbmNlIGRhdGEgbW92ZXMgaGF2ZSBuZXQgemVybyBlZmZlY3QgKHdlXG4gICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgZGF0YSBmcm9tIHRoZSBvbGQgYmFja2VuZCksIHdlIGhhdmUgdG8gY2FuY2VsIHRoZW0gb3V0XG4gICAgLy8gd2hlbiBkZXRlY3RpbmcgbWVtb3J5IGxlYWtzLlxuICAgIGNvbnN0IG51bU1vdmVzID1cbiAgICAgICAgdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRhdGFJZHNMZWFrZWQgPVxuICAgICAgICBudW1EYXRhSWRzQWZ0ZXIgLSBudW1EYXRhSWRzQmVmb3JlIC0gbnVtT3V0cHV0RGF0YUlkcyAtIG51bU1vdmVzO1xuICAgIGlmIChkYXRhSWRzTGVha2VkID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBCYWNrZW5kICcke3RoaXMuYmFja2VuZE5hbWV9JyBoYXMgYW4gaW50ZXJuYWwgbWVtb3J5IGxlYWsgYCArXG4gICAgICAgICAgYCgke2RhdGFJZHNMZWFrZWR9IGRhdGEgaWRzKSBhZnRlciBydW5uaW5nICcke2tlcm5lbE5hbWV9J2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHRvIGV4ZWN1dGUgYSBrZXJuZWwgRnVuY1xuICAgKlxuICAgKiBVc2UgYHJ1bktlcm5lbGAgdG8gZXhlY3V0ZSBrZXJuZWxzIGZyb20gb3V0c2lkZSBvZiBlbmdpbmUuXG4gICAqL1xuICBwcml2YXRlIHJ1bktlcm5lbEZ1bmM8VCBleHRlbmRzIFRlbnNvcnxUZW5zb3JbXSwgSSBleHRlbmRzIE5hbWVkVGVuc29yTWFwPihcbiAgICAgIGtlcm5lbFBhcmFtczogUmVnaXN0ZXJlZEtlcm5lbEludm9jYXRpb248ST58XG4gICAgICBDdXN0b21HcmFkS2VybmVsSW52b2NhdGlvbjxULCBJPik6IFQge1xuICAgIGxldCBvdXRwdXRzOiBUZW5zb3JbXTtcbiAgICBsZXQgc2F2ZWQ6IFRlbnNvcltdID0gW107XG4gICAgY29uc3QgaXNUYXBlT24gPSB0aGlzLmlzVGFwZU9uKCk7XG5cbiAgICBjb25zdCBzdGFydGluZ0J5dGVjb3VudCA9IHRoaXMuc3RhdGUubnVtQnl0ZXM7XG4gICAgY29uc3Qgc3RhcnRpbmdOdW1UZW5zb3JzID0gdGhpcy5zdGF0ZS5udW1UZW5zb3JzO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpKSB7XG4gICAgICB0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLnB1c2goMCk7XG4gICAgfVxuXG4gICAgbGV0IGtlcm5lbEZ1bmM6ICgpID0+IFRlbnNvcltdO1xuICAgIGlmICh0aGlzLmJhY2tlbmROYW1lID09IG51bGwpIHtcbiAgICAgIC8vIGJhY2tlbmQgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldCAoYmFja2VuZCBpbml0aWFsaXphdGlvbiBpcyBsYXp5XG4gICAgICAvLyBjYW4gYmUgZGVmZXJyZWQgdW50aWwgYW4gb3AvIGtlcm5lbCBpcyBydW4pLlxuICAgICAgLy8gVGhlIGJlbG93IGdldHRlciBoYXMgc2lkZSBlZmZlY3RzIHRoYXQgd2lsbCB0cnkgdG8gaW5pdGlhbGl6ZSB0aGVcbiAgICAgIC8vIGJhY2tlbmQgYW5kIHNldCBwcm9wZXJ0aWVzIGxpa2UgdGhpcy5iYWNrZW5kTmFtZVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgdGhpcy5iYWNrZW5kO1xuICAgIH1cblxuICAgIGxldCBvdXQ6IFRlbnNvckluZm98VGVuc29ySW5mb1tdO1xuXG4gICAgY29uc3Qga2VybmVsT3JTY29wZU5hbWUgPSBpc1JlZ2lzdGVyZWRLZXJuZWxJbnZvY2F0aW9uKGtlcm5lbFBhcmFtcykgP1xuICAgICAgICBrZXJuZWxQYXJhbXMua2VybmVsTmFtZSA6XG4gICAgICAgIHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUgIT0gbnVsbCA/IHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZSA6ICcnO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBrZXJuZWxGdW5jIGZyb20gZWl0aGVyIGEgcmVnaXN0ZXJlZCBrZXJuZWwgT1IgcGFzc2VkIGluXG4gICAgLy8gZm9yd2FyZC9iYWNrd2FyZCBmdW5jdGlvbnMgKHVzZWQgYnkgY3VzdG9tIGdyYWQpLiBJbiB0aGlzIGNvbnRleHQgYVxuICAgIC8vIGtlcm5lbEZ1bmMgd3JhcHMgYSBrZXJuZWwgaW1wbGVtZW50YXRpb24gd2l0aCBzb21lIGJvb2trZWVwaW5nLlxuXG4gICAgaWYgKGlzUmVnaXN0ZXJlZEtlcm5lbEludm9jYXRpb24oa2VybmVsUGFyYW1zKSkge1xuICAgICAgY29uc3Qge2tlcm5lbE5hbWUsIGlucHV0cywgYXR0cnN9ID0ga2VybmVsUGFyYW1zO1xuICAgICAgaWYgKHRoaXMuYmFja2VuZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAvLyBiYWNrZW5kIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQgKGJhY2tlbmQgaW5pdGlhbGl6YXRpb24gaXMgbGF6eVxuICAgICAgICAvLyBjYW4gYmUgZGVmZXJyZWQgdW50aWwgYW4gb3AvIGtlcm5lbCBpcyBydW4pLlxuICAgICAgICAvLyBUaGUgYmVsb3cgZ2V0dGVyIGhhcyBzaWRlIGVmZmVjdHMgdGhhdCB3aWxsIHRyeSB0byBpbml0aWFsaXplIHRoZVxuICAgICAgICAvLyBiYWNrZW5kIGFuZCBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuYmFja2VuZE5hbWVcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgICB0aGlzLmJhY2tlbmQ7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXJuZWwgPSBnZXRLZXJuZWwoa2VybmVsTmFtZSwgdGhpcy5iYWNrZW5kTmFtZSk7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBrZXJuZWwgIT0gbnVsbCxcbiAgICAgICAgICAoKSA9PiBgQ2Fubm90IGZpbmQgcmVnaXN0ZXJlZCBrZXJuZWwgJyR7a2VybmVsTmFtZX0nIGZvciBiYWNrZW5kICcke1xuICAgICAgICAgICAgICB0aGlzLmJhY2tlbmROYW1lfSdgKTtcblxuICAgICAga2VybmVsRnVuYyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbnVtRGF0YUlkc0JlZm9yZSA9IHRoaXMuYmFja2VuZC5udW1EYXRhSWRzKCk7XG4gICAgICAgIG91dCA9IGtlcm5lbC5rZXJuZWxGdW5jKHtpbnB1dHMsIGF0dHJzLCBiYWNrZW5kOiB0aGlzLmJhY2tlbmR9KTtcbiAgICAgICAgY29uc3Qgb3V0SW5mb3MgPSBBcnJheS5pc0FycmF5KG91dCkgPyBvdXQgOiBbb3V0XTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0tlcm5lbEZvck1lbUxlYWsoa2VybmVsTmFtZSwgbnVtRGF0YUlkc0JlZm9yZSwgb3V0SW5mb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0VGVuc29ycyA9IG91dEluZm9zLm1hcCgob3V0SW5mbzogVGVuc29ySW5mb3xUZW5zb3IpID0+IHtcbiAgICAgICAgICAvLyB0b2RvICh5YXNzb2diYSkgcmVtb3ZlIHRoaXMgb3B0aW9uIChUZW5zb3IpIHdoZW4gbm9kZSBiYWNrZW5kXG4gICAgICAgICAgLy8gbWV0aG9kcyBoYXZlIGJlZW4gbW9kdWxhcml6ZWQgYW5kIHRoZXkgYWxsIHJldHVybiB0ZW5zb3JJbmZvLlxuICAgICAgICAgIC8vIFRlbnNvckluZm9zIGRvIG5vdCBoYXZlIGEgcmFuayBhdHRyaWJ1dGUuXG4gICAgICAgICAgaWYgKChvdXRJbmZvIGFzIFRlbnNvcikucmFuayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0SW5mbyBhcyBUZW5zb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyhvdXRJbmZvKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcmVxdWlyZWQgaW5wdXRzIGFuZCBvdXRwdXRzLlxuXG4gICAgICAgIC8vIERvIG5vdCBzYXZlIHVubGVzcyB3ZSBhcmUgcmVjb3JkaW5nIHRvIHRoZSB0YXBlLiBPdGhlcndpc2UgaXQgd291bGRcbiAgICAgICAgLy8gY2F1c2UgYSBtZW0gbGVhayBzaW5jZSB0aGVyZSB3b3VsZCBiZSBubyBiYWNrcHJvcCBmb3IgdGhlc2UgdGVuc29yc1xuICAgICAgICAvLyAod2hpY2ggd291bGQgb3RoZXJ3aXNlIGRpc3Bvc2UgdGhlbSkuXG4gICAgICAgIGlmIChpc1RhcGVPbikge1xuICAgICAgICAgIGNvbnN0IHRlbnNvcnNUb1NhdmUgPVxuICAgICAgICAgICAgICB0aGlzLmdldFRlbnNvcnNGb3JHcmFkaWVudChrZXJuZWxOYW1lLCBpbnB1dHMsIG91dFRlbnNvcnMpO1xuICAgICAgICAgIHNhdmVkID0gdGhpcy5zYXZlVGVuc29yc0ZvckJhY2t3YXJkTW9kZSh0ZW5zb3JzVG9TYXZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0VGVuc29ycztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtmb3J3YXJkRnVuY30gPSBrZXJuZWxQYXJhbXM7XG4gICAgICAvLyBSdW5uaW5nIGEgY3VzdG9tR3JhZCBvcC5cbiAgICAgIGNvbnN0IHNhdmVGdW5jOiBHcmFkU2F2ZUZ1bmMgPSAodGVuc29ycykgPT4ge1xuICAgICAgICAvLyBEbyBub3Qgc2F2ZSB1bmxlc3Mgd2UgYXJlIHJlY29yZGluZyB0byB0aGUgdGFwZS4gT3RoZXJ3aXNlIGl0IHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGEgbWVtIGxlYWsgc2luY2Ugd2Ugd291bGQgbmV2ZXIgcnVuIGJhY2twcm9wLCB3aGljaCBkaXNwb3Nlc1xuICAgICAgICAvLyB0aGUga2VwdCB0ZW5zb3JzLlxuICAgICAgICBpZiAoIWlzVGFwZU9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNhdmVkID0gdGVuc29ycy5tYXAodGVuc29yID0+IHRoaXMua2VlcCh0aGlzLmNsb25lKHRlbnNvcikpKTtcbiAgICAgIH07XG5cbiAgICAgIGtlcm5lbEZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bURhdGFJZHNCZWZvcmUgPSB0aGlzLmJhY2tlbmQubnVtRGF0YUlkcygpO1xuICAgICAgICBvdXQgPSB0aGlzLnRpZHkoKCkgPT4gZm9yd2FyZEZ1bmModGhpcy5iYWNrZW5kLCBzYXZlRnVuYykpO1xuICAgICAgICBjb25zdCBvdXRzID0gKEFycmF5LmlzQXJyYXkob3V0KSA/IG91dCA6IFtvdXRdKSBhcyBUZW5zb3JbXTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpKSB7XG4gICAgICAgICAgLy8gU2NvcGUgbmFtZSBpcyB1c2VkIHRvIHByaW50IGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgaWYgbmVlZGVkLlxuICAgICAgICAgIHRoaXMuY2hlY2tLZXJuZWxGb3JNZW1MZWFrKGtlcm5lbE9yU2NvcGVOYW1lLCBudW1EYXRhSWRzQmVmb3JlLCBvdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSdW4gdGhlIGtlcm5lbEZ1bmMuIE9wdGlvbmFsbHkgcHJvZmlsaW5nIGl0LlxuICAgIC8vXG4gICAgY29uc3Qge2lucHV0cywgYXR0cnN9ID0ga2VybmVsUGFyYW1zO1xuICAgIGNvbnN0IGJhY2t3YXJkc0Z1bmMgPSBpc1JlZ2lzdGVyZWRLZXJuZWxJbnZvY2F0aW9uKGtlcm5lbFBhcmFtcykgP1xuICAgICAgICBudWxsIDpcbiAgICAgICAga2VybmVsUGFyYW1zLmJhY2t3YXJkc0Z1bmM7XG5cbiAgICBsZXQga2VybmVsUHJvZmlsZTogS2VybmVsUHJvZmlsZTtcbiAgICB0aGlzLnNjb3BlZFJ1bihcbiAgICAgICAgLy8gU3RvcCByZWNvcmRpbmcgdG8gYSB0YXBlIHdoZW4gcnVubmluZyBhIGtlcm5lbC5cbiAgICAgICAgKCkgPT4gdGhpcy5zdGF0ZS5rZXJuZWxEZXB0aCsrLCAoKSA9PiB0aGlzLnN0YXRlLmtlcm5lbERlcHRoLS0sICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuRU5WLmdldEJvb2woJ0RFQlVHJykgJiYgIXRoaXMuc3RhdGUucHJvZmlsaW5nKSB7XG4gICAgICAgICAgICBvdXRwdXRzID0ga2VybmVsRnVuYygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXJuZWxQcm9maWxlID0gdGhpcy5wcm9maWxlci5wcm9maWxlS2VybmVsKFxuICAgICAgICAgICAgICAgIGtlcm5lbE9yU2NvcGVOYW1lLCBpbnB1dHMsICgpID0+IGtlcm5lbEZ1bmMoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5FTlYuZ2V0Qm9vbCgnREVCVUcnKSkge1xuICAgICAgICAgICAgICB0aGlzLnByb2ZpbGVyLmxvZ0tlcm5lbFByb2ZpbGUoa2VybmVsUHJvZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRzID0ga2VybmVsUHJvZmlsZS5vdXRwdXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICBpZiAoaXNUYXBlT24pIHtcbiAgICAgIHRoaXMuYWRkVGFwZU5vZGUoXG4gICAgICAgICAga2VybmVsT3JTY29wZU5hbWUsIGlucHV0cywgb3V0cHV0cywgYmFja3dhcmRzRnVuYywgc2F2ZWQsIGF0dHJzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5wcm9maWxpbmcpIHtcbiAgICAgIHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXJuZWxPclNjb3BlTmFtZSxcbiAgICAgICAgYnl0ZXNBZGRlZDogdGhpcy5zdGF0ZS5udW1CeXRlcyAtIHN0YXJ0aW5nQnl0ZWNvdW50LFxuICAgICAgICB0b3RhbEJ5dGVzU25hcHNob3Q6IHRoaXMuc3RhdGUubnVtQnl0ZXMsXG4gICAgICAgIHRlbnNvcnNBZGRlZDogdGhpcy5zdGF0ZS5udW1UZW5zb3JzIC0gc3RhcnRpbmdOdW1UZW5zb3JzLFxuICAgICAgICB0b3RhbFRlbnNvcnNTbmFwc2hvdDogdGhpcy5zdGF0ZS5udW1UZW5zb3JzLFxuICAgICAgICBpbnB1dFNoYXBlczogT2JqZWN0LmtleXMoaW5wdXRzKS5tYXAoXG4gICAgICAgICAgICBrZXkgPT4gaW5wdXRzW2tleV0gIT0gbnVsbCA/IGlucHV0c1trZXldLnNoYXBlIDogbnVsbCksXG4gICAgICAgIG91dHB1dFNoYXBlczogb3V0cHV0cy5tYXAoaXRlbSA9PiBpdGVtLnNoYXBlKSxcbiAgICAgICAga2VybmVsVGltZU1zOiBrZXJuZWxQcm9maWxlLnRpbWVNcyxcbiAgICAgICAgZXh0cmFJbmZvOiBrZXJuZWxQcm9maWxlLmV4dHJhSW5mb1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShvdXQpID8gb3V0cHV0cyA6IG91dHB1dHNbMF0pIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGVuc29ycyB1c2VkIGluIGZvcndhcmQgbW9kZSBmb3IgdXNlIGluIGJhY2t3YXJkIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3JzIHRoZSBsaXN0IG9mIHRlbnNvcnMgdG8gc2F2ZS5cbiAgICovXG4gIHByaXZhdGUgc2F2ZVRlbnNvcnNGb3JCYWNrd2FyZE1vZGUodGVuc29yczogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3Qgc2F2ZWQgPSB0ZW5zb3JzLm1hcCh0ZW5zb3IgPT4gdGhpcy5rZWVwKHRoaXMuY2xvbmUodGVuc29yKSkpO1xuICAgIHJldHVybiBzYXZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0ZW5zb3JzIHRvIHNhdmUgZm9yIGEgZ2l2ZW4gZ3JhZGllbnQgY2FsY3VsYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBrZXJuZWxOYW1lIG5hbWUgb2Yga2VybmVsIHRvIGxvb2sgdXAgZ3JhZGllbnQgZm9yLlxuICAgKiBAcGFyYW0gaW5wdXRzIGEgbWFwIG9mIGlucHV0IHRlbnNvcnMuXG4gICAqIEBwYXJhbSBvdXRwdXRzIGFuIGFycmF5IG9mIG91dHB1dCB0ZW5zb3JzIGZyb20gZm9yd2FyZCBtb2RlIG9mIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUgZ2V0VGVuc29yc0ZvckdyYWRpZW50KFxuICAgICAga2VybmVsTmFtZTogc3RyaW5nLCBpbnB1dHM6IE5hbWVkVGVuc29yTWFwLFxuICAgICAgb3V0cHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxudWxsIHtcbiAgICBjb25zdCBncmFkQ29uZmlnID0gZ2V0R3JhZGllbnQoa2VybmVsTmFtZSk7XG4gICAgaWYgKGdyYWRDb25maWcgIT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5wdXRzVG9TYXZlOiBzdHJpbmdbXSA9IGdyYWRDb25maWcuaW5wdXRzVG9TYXZlIHx8IFtdO1xuICAgICAgY29uc3Qgb3V0cHV0c1RvU2F2ZTogYm9vbGVhbltdID0gZ3JhZENvbmZpZy5vdXRwdXRzVG9TYXZlIHx8IFtdO1xuXG4gICAgICAvLyBJZiBzYXZlQWxsSW5wdXRzIGlzIHRydWUsIGFsbCBpbnB1dHMgd2lsbCBiZSBzYXZlZC4gT3RoZXJ3aXNlLCBpbnB1dHNcbiAgICAgIC8vIHNwZWNpZmllZCBpbiBpbnB1dHNUb1NhdmUgd2lsbCBiZSBzYXZlZC5cbiAgICAgIGxldCBpbnB1dFRlbnNvcnNUb1NhdmU6IFRlbnNvcltdO1xuICAgICAgaWYgKGdyYWRDb25maWcuc2F2ZUFsbElucHV0cykge1xuICAgICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRzKSxcbiAgICAgICAgICAgICgpID0+ICdzYXZlQWxsSW5wdXRzIGlzIHRydWUsIGV4cGVjdGVkIGlucHV0cyB0byBiZSBhbiBhcnJheS4nKTtcblxuICAgICAgICBpbnB1dFRlbnNvcnNUb1NhdmUgPSBPYmplY3Qua2V5cyhpbnB1dHMpLm1hcCgoa2V5KSA9PiBpbnB1dHNba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dFRlbnNvcnNUb1NhdmUgPSBpbnB1dHNUb1NhdmUubWFwKChpbnB1dE5hbWUpID0+IGlucHV0c1tpbnB1dE5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0VGVuc29yc1RvU2F2ZTogVGVuc29yW10gPVxuICAgICAgICAgIG91dHB1dHMuZmlsdGVyKChfLCBpKSA9PiBvdXRwdXRzVG9TYXZlW2ldKTtcblxuICAgICAgcmV0dXJuIGlucHV0VGVuc29yc1RvU2F2ZS5jb25jYXQob3V0cHV0VGVuc29yc1RvU2F2ZSk7XG4gICAgfVxuICAgIC8vIFdlIHJldHVybiBhbiBlbXB0eSBsaXN0IHJhdGhlciB0aGFuIHRocm93IGFuIGVycm9yIGJlY2F1c2UgdGhlIGtlcm5lbCB3ZVxuICAgIC8vIGFyZSBsb29raW5nIHVwIG1heSBub3QgYWN0dWFsbHkgYmUgcmVsZXZhbnQgdG8gYmFja3Byb3BpbmcgdGhyb3VnaCB0aGVcbiAgICAvLyBvdmVyYWxsIGZ1bmN0aW9uXG4gICAgLy9cbiAgICAvLyBTZWUgJ2RvZXMgbm90IGVycm9yIGlmIGlycmVsZXZhbnQgKHBydW5lZCkgb3BzIGFyZSBtaXNzaW5nIGdyYWRzJyB0ZXN0XG4gICAgLy8gaW4gZ3JhZGllbnRzX3Rlc3QudHMgZm9yIGFuIGV4YW1wbGUuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCB1c2VkIGJ5IHB1YmxpYyBBUElzIGZvciB0ZW5zb3IgY3JlYXRpb24uIE1ha2VzIGEgbmV3XG4gICAqIHRlbnNvciB3aXRoIHRoZSBwcm92aWRlZCBzaGFwZSwgZHR5cGUgYW5kIHZhbHVlcy4gSXQgYWx3YXlzXG4gICAqIGNyZWF0ZXMgYSBuZXcgZGF0YSBpZCBhbmQgd3JpdGVzIHRoZSB2YWx1ZXMgdG8gdGhlIHVuZGVybHlpbmcgYmFja2VuZC5cbiAgICovXG4gIG1ha2VUZW5zb3IoXG4gICAgICB2YWx1ZXM6IERhdGFWYWx1ZXMsIHNoYXBlOiBudW1iZXJbXSwgZHR5cGU6IERhdGFUeXBlLFxuICAgICAgYmFja2VuZD86IEtlcm5lbEJhY2tlbmQpOiBUZW5zb3Ige1xuICAgIGlmICh2YWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZXMgcGFzc2VkIHRvIGVuZ2luZS5tYWtlVGVuc29yKCkgYXJlIG51bGwnKTtcbiAgICB9XG4gICAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgYmFja2VuZCA9IGJhY2tlbmQgfHwgdGhpcy5iYWNrZW5kO1xuICAgIGxldCBiYWNrZW5kVmFscyA9IHZhbHVlcyBhcyBCYWNrZW5kVmFsdWVzO1xuICAgIGlmIChkdHlwZSA9PT0gJ3N0cmluZycgJiYgdXRpbC5pc1N0cmluZyh2YWx1ZXNbMF0pKSB7XG4gICAgICBiYWNrZW5kVmFscyA9ICh2YWx1ZXMgYXMgc3RyaW5nW10pLm1hcChkID0+IHV0aWwuZW5jb2RlU3RyaW5nKGQpKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YUlkID0gYmFja2VuZC53cml0ZShiYWNrZW5kVmFscywgc2hhcGUsIGR0eXBlKTtcbiAgICBjb25zdCB0ID0gbmV3IFRlbnNvcihzaGFwZSwgZHR5cGUsIGRhdGFJZCwgdGhpcy5uZXh0VGVuc29ySWQoKSk7XG4gICAgdGhpcy50cmFja1RlbnNvcih0LCBiYWNrZW5kKTtcblxuICAgIC8vIENvdW50IGJ5dGVzIGZvciBzdHJpbmcgdGVuc29ycy5cbiAgICBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldChkYXRhSWQpO1xuICAgICAgY29uc3QgbmV3Qnl0ZXMgPSBieXRlc0Zyb21TdHJpbmdBcnJheShiYWNrZW5kVmFscyBhcyBVaW50OEFycmF5W10pO1xuICAgICAgdGhpcy5zdGF0ZS5udW1CeXRlcyArPSBuZXdCeXRlcyAtIGluZm8uYnl0ZXM7XG4gICAgICBpbmZvLmJ5dGVzID0gbmV3Qnl0ZXM7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCB1c2VkIGJ5IGJhY2tlbmRzLiBNYWtlcyBhIG5ldyB0ZW5zb3IgdGhhdCBpcyBhIHdyYXBwZXJcbiAgICogYXJvdW5kIGFuIGV4aXN0aW5nIGRhdGEgaWQgaW4gVGVuc29ySW5mby4gSXQgZG9lc24ndCBjcmVhdGUgYSBuZXcgZGF0YSBpZCxcbiAgICogb25seSBpbmNyZW1lbnRzIHRoZSByZWYgY291bnQgdXNlZCBpbiBtZW1vcnkgdHJhY2tpbmcuXG4gICAqL1xuICBtYWtlVGVuc29yRnJvbVRlbnNvckluZm8odGVuc29ySW5mbzogVGVuc29ySW5mbywgYmFja2VuZD86IEtlcm5lbEJhY2tlbmQpOlxuICAgICAgVGVuc29yIHtcbiAgICBjb25zdCB7ZGF0YUlkLCBzaGFwZSwgZHR5cGV9ID0gdGVuc29ySW5mbztcbiAgICBjb25zdCB0ID0gbmV3IFRlbnNvcihzaGFwZSwgZHR5cGUsIGRhdGFJZCwgdGhpcy5uZXh0VGVuc29ySWQoKSk7XG4gICAgdGhpcy50cmFja1RlbnNvcih0LCBiYWNrZW5kKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIG1ha2VWYXJpYWJsZShcbiAgICAgIGluaXRpYWxWYWx1ZTogVGVuc29yLCB0cmFpbmFibGUgPSB0cnVlLCBuYW1lPzogc3RyaW5nLFxuICAgICAgZHR5cGU/OiBEYXRhVHlwZSk6IFZhcmlhYmxlIHtcbiAgICBuYW1lID0gbmFtZSB8fCB0aGlzLm5leHRWYXJpYWJsZUlkKCkudG9TdHJpbmcoKTtcbiAgICBpZiAoZHR5cGUgIT0gbnVsbCAmJiBkdHlwZSAhPT0gaW5pdGlhbFZhbHVlLmR0eXBlKSB7XG4gICAgICBpbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWUuY2FzdChkdHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHYgPSBuZXcgVmFyaWFibGUoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUsIHRoaXMubmV4dFRlbnNvcklkKCkpO1xuICAgIGlmICh0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdi5uYW1lXSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIHdpdGggbmFtZSAke3YubmFtZX0gd2FzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdi5uYW1lXSA9IHY7XG4gICAgdGhpcy5pbmNSZWYodiwgdGhpcy5iYWNrZW5kKTtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHRyYWNrVGVuc29yKGE6IFRlbnNvciwgYmFja2VuZDogS2VybmVsQmFja2VuZCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGUubnVtVGVuc29ycysrO1xuICAgIGlmIChhLmR0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzKys7XG4gICAgfVxuICAgIC8vIEJ5dGVzIGZvciBjb21wbGV4IG51bWJlcnMgYXJlIGNvdW50ZWQgYnkgdGhlaXIgY29tcG9uZW50cy4gQnl0ZXMgZm9yXG4gICAgLy8gc3RyaW5nIHRlbnNvcnMgYXJlIGNvdW50ZWQgd2hlbiB3cml0aW5nIHZhbHVlcy5cbiAgICBsZXQgYnl0ZXMgPSAwO1xuICAgIGlmIChhLmR0eXBlICE9PSAnY29tcGxleDY0JyAmJiBhLmR0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZXMgPSBhLnNpemUgKiB1dGlsLmJ5dGVzUGVyRWxlbWVudChhLmR0eXBlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5udW1CeXRlcyArPSBieXRlcztcblxuICAgIGlmICghdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyhhLmRhdGFJZCkpIHtcbiAgICAgIHRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMrKztcbiAgICAgIHRoaXMuc3RhdGUudGVuc29ySW5mby5zZXQoYS5kYXRhSWQsIHtcbiAgICAgICAgYmFja2VuZDogYmFja2VuZCB8fCB0aGlzLmJhY2tlbmQsXG4gICAgICAgIGR0eXBlOiBhLmR0eXBlLFxuICAgICAgICBzaGFwZTogYS5zaGFwZSxcbiAgICAgICAgYnl0ZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghKGEgaW5zdGFuY2VvZiBWYXJpYWJsZSkpIHtcbiAgICAgIHRoaXMudHJhY2soYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhY2sgdGhlIHRlbnNvciBieSBkYXRhSWQgYW5kIGluY3JlYXNlIHRoZSByZWZDb3VudCBmb3IgdGhlIGRhdGFJZCBpbiB0aGVcbiAgLy8gYmFja2VuZC5cbiAgLy8gVE9ETyhweXUxMDA1NSk6IFRoaXMgaXMgY3VycmVudGx5IHVzZWQgYnkgbWFrZVZhcmlhYmxlIG1ldGhvZCwgdG8gaW5jcmVhc2VcbiAgLy8gcmVmQ291bnQgb24gdGhlIGJhY2tlbmQgZm9yIHRoZSBkYXRhSWQuIEl0IGNhbiBwb3RlbnRpYWxseSBiZSByZXBsYWNlZCB3aXRoXG4gIC8vIElkZW50aXR5IG9wIGluZGVhZCBvZiBjYWxsaW5nIGJhY2tlbmQgZGlyZWN0bHkuXG4gIGluY1JlZihhOiBUZW5zb3IsIGJhY2tlbmQ6IEtlcm5lbEJhY2tlbmQpOiB2b2lkIHtcbiAgICB0aGlzLnRyYWNrVGVuc29yKGEsIGJhY2tlbmQpO1xuICAgIHRoaXMuYmFja2VuZC5pbmNSZWYoYS5kYXRhSWQpO1xuICB9XG5cbiAgcmVtb3ZlRGF0YUlkKGRhdGFJZDogRGF0YUlkLCBiYWNrZW5kOiBLZXJuZWxCYWNrZW5kKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudGVuc29ySW5mby5oYXMoZGF0YUlkKSAmJlxuICAgICAgICB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGRhdGFJZCkuYmFja2VuZCA9PT0gYmFja2VuZCkge1xuICAgICAgdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgdGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycy0tO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlVGVuc29yKGE6IFRlbnNvcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyhhLmRhdGFJZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoYS5kYXRhSWQpO1xuXG4gICAgdGhpcy5zdGF0ZS5udW1UZW5zb3JzLS07XG4gICAgaWYgKGEuZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMtLTtcbiAgICAgIHRoaXMuc3RhdGUubnVtQnl0ZXMgLT0gaW5mby5ieXRlcztcbiAgICB9XG4gICAgLy8gRG9uJ3QgY291bnQgYnl0ZXMgZm9yIGNvbXBsZXggbnVtYmVycyBhcyB0aGV5IGFyZSBjb3VudGVkIGJ5IHRoZWlyXG4gICAgLy8gY29tcG9uZW50cy5cbiAgICBpZiAoYS5kdHlwZSAhPT0gJ2NvbXBsZXg2NCcgJiYgYS5kdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gYS5zaXplICogdXRpbC5ieXRlc1BlckVsZW1lbnQoYS5kdHlwZSk7XG4gICAgICB0aGlzLnN0YXRlLm51bUJ5dGVzIC09IGJ5dGVzO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIGRhdGFJZCBpZiBiYWNrZW5kIGRpc3Bvc2UgdGhlIGRhdGEgc3VjY2Vzc2Z1bGx5XG4gICAgaWYgKGluZm8uYmFja2VuZC5kaXNwb3NlRGF0YShhLmRhdGFJZCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlRGF0YUlkKGEuZGF0YUlkLCBpbmZvLmJhY2tlbmQpO1xuICAgIH1cblxuICAgIC8vIFRPRE8obnN0aG9yYXQpOiBDb25zdHJ1Y3QgYW4gZXJyb3IgYW5kIHNhdmUgdGhlIHN0YWNrIHRyYWNlIGZvclxuICAgIC8vIGRlYnVnZ2luZyB3aGVuIGluIGRlYnVnIG1vZGUuIENyZWF0aW5nIGEgc3RhY2sgdHJhY2UgaXMgdG9vIGV4cGVuc2l2ZVxuICAgIC8vIHRvIGRvIHVuY29uZGl0aW9uYWxseS5cbiAgfVxuXG4gIGRpc3Bvc2VWYXJpYWJsZXMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCB2YXJOYW1lIGluIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlcykge1xuICAgICAgY29uc3QgdiA9IHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJOYW1lXTtcbiAgICAgIHRoaXMuZGlzcG9zZVZhcmlhYmxlKHYpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2VWYXJpYWJsZSh2OiBWYXJpYWJsZSk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZVRlbnNvcih2KTtcbiAgICBpZiAodGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3YubmFtZV0gIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2Lm5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIG1lbW9yeSgpOiBNZW1vcnlJbmZvIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5iYWNrZW5kLm1lbW9yeSgpIGFzIE1lbW9yeUluZm87XG4gICAgaW5mby5udW1UZW5zb3JzID0gdGhpcy5zdGF0ZS5udW1UZW5zb3JzO1xuICAgIGluZm8ubnVtRGF0YUJ1ZmZlcnMgPSB0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzO1xuICAgIGluZm8ubnVtQnl0ZXMgPSB0aGlzLnN0YXRlLm51bUJ5dGVzO1xuICAgIGlmICh0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMgPiAwKSB7XG4gICAgICBpbmZvLnVucmVsaWFibGUgPSB0cnVlO1xuICAgICAgaWYgKGluZm8ucmVhc29ucyA9PSBudWxsKSB7XG4gICAgICAgIGluZm8ucmVhc29ucyA9IFtdO1xuICAgICAgfVxuICAgICAgaW5mby5yZWFzb25zLnB1c2goXG4gICAgICAgICAgJ01lbW9yeSB1c2FnZSBieSBzdHJpbmcgdGVuc29ycyBpcyBhcHByb3hpbWF0ZSAnICtcbiAgICAgICAgICAnKDIgYnl0ZXMgcGVyIGNoYXJhY3RlciknKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBhc3luYyBwcm9maWxlKHF1ZXJ5OiAoKSA9PiAoVGVuc29yQ29udGFpbmVyIHwgUHJvbWlzZTxUZW5zb3JDb250YWluZXI+KSk6XG4gICAgICBQcm9taXNlPFByb2ZpbGVJbmZvPiB7XG4gICAgdGhpcy5zdGF0ZS5wcm9maWxpbmcgPSB0cnVlO1xuXG4gICAgY29uc3Qgc3RhcnRCeXRlcyA9IHRoaXMuc3RhdGUubnVtQnl0ZXM7XG4gICAgY29uc3Qgc3RhcnROdW1UZW5zb3JzID0gdGhpcy5zdGF0ZS5udW1UZW5zb3JzO1xuXG4gICAgdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMgPSBbXTtcbiAgICB0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucmVzdWx0ID0gYXdhaXQgcXVlcnkoKTtcblxuICAgIHRoaXMuc3RhdGUucHJvZmlsaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLm1hcChkID0+IGQudG90YWxCeXRlc1NuYXBzaG90KSk7XG4gICAgdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld0J5dGVzID0gdGhpcy5zdGF0ZS5udW1CeXRlcyAtIHN0YXJ0Qnl0ZXM7XG4gICAgdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld1RlbnNvcnMgPVxuICAgICAgICB0aGlzLnN0YXRlLm51bVRlbnNvcnMgLSBzdGFydE51bVRlbnNvcnM7XG4gICAgZm9yIChjb25zdCBrZXJuZWwgb2YgdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMpIHtcbiAgICAgIGtlcm5lbC5rZXJuZWxUaW1lTXMgPSBhd2FpdCBrZXJuZWwua2VybmVsVGltZU1zO1xuICAgICAga2VybmVsLmV4dHJhSW5mbyA9IGF3YWl0IGtlcm5lbC5leHRyYUluZm87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGU7XG4gIH1cblxuICBpc1RhcGVPbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoID4gMCAmJiB0aGlzLnN0YXRlLmtlcm5lbERlcHRoID09PSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUYXBlTm9kZShcbiAgICAgIGtlcm5lbE5hbWU6IHN0cmluZywgaW5wdXRzOiBOYW1lZFRlbnNvck1hcCwgb3V0cHV0czogVGVuc29yW10sXG4gICAgICBncmFkaWVudHNGdW5jOiBHcmFkRnVuYywgc2F2ZWQ6IFRlbnNvcltdLCBhdHRyczogTmFtZWRBdHRyTWFwKTogdm9pZCB7XG4gICAgY29uc3QgdGFwZU5vZGU6IFRhcGVOb2RlID1cbiAgICAgICAge2lkOiB0aGlzLnN0YXRlLm5leHRUYXBlTm9kZUlkKyssIGtlcm5lbE5hbWUsIGlucHV0cywgb3V0cHV0cywgc2F2ZWR9O1xuXG4gICAgY29uc3QgZ3JhZENvbmZpZyA9IGdldEdyYWRpZW50KGtlcm5lbE5hbWUpO1xuICAgIGlmIChncmFkQ29uZmlnICE9IG51bGwpIHtcbiAgICAgIGdyYWRpZW50c0Z1bmMgPSBncmFkQ29uZmlnLmdyYWRGdW5jO1xuICAgIH1cbiAgICBpZiAoZ3JhZGllbnRzRnVuYyAhPSBudWxsKSB7XG4gICAgICB0YXBlTm9kZS5ncmFkaWVudCA9IChkeXM6IFRlbnNvcltdKSA9PiB7XG4gICAgICAgIC8vIFRPRE8oc21pbGtvdik6IFRvIG9wdGltaXplIGJhY2stcHJvcCwgcGFzcyBkeXMgdGhhdCBhcmUgbm90IHVzZWQgaW5cbiAgICAgICAgLy8gdGhlIGJhY2twcm9wIGdyYXBoIHRvIHRoZSB1c2VyIGFzIG51bGwgaW5zdGVhZCBvZiB6ZXJvc1xuICAgICAgICBkeXMgPSBkeXMubWFwKChkeSwgaSkgPT4ge1xuICAgICAgICAgIGlmIChkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFscyA9IHV0aWwubWFrZVplcm9zVHlwZWRBcnJheShvdXRwdXQuc2l6ZSwgb3V0cHV0LmR0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VUZW5zb3IodmFscywgb3V0cHV0LnNoYXBlLCBvdXRwdXQuZHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZHk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBHcmFkIGZ1bmN0aW9ucyBvZiBvcHMgd2l0aCBzaW5nbGUgb3V0cHV0cyBleHBlY3QgYSBkeSwgd2hpbGUgb3BzXG4gICAgICAgIC8vIHdpdGggbXVsdGlwbGUgb3V0cHV0cyBleHBlY3QgZHlzIChhcnJheSBvZiBkeSkuXG4gICAgICAgIHJldHVybiBncmFkaWVudHNGdW5jKGR5cy5sZW5ndGggPiAxID8gZHlzIDogZHlzWzBdLCBzYXZlZCwgYXR0cnMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5hY3RpdmVUYXBlLnB1c2godGFwZU5vZGUpO1xuICB9XG5cbiAga2VlcDxUIGV4dGVuZHMgVGVuc29yPihyZXN1bHQ6IFQpOiBUIHtcbiAgICByZXN1bHQua2VwdCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRUYXBlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUuYWN0aXZlVGFwZSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgrKztcbiAgfVxuXG4gIHByaXZhdGUgZW5kVGFwZSgpIHtcbiAgICB0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgtLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIHNjb3BlLiBVc2UgdGhpcyB3aXRoIGVuZFNjb3BlKCkgdG8gYWNoaWV2ZSB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5XG4gICAqIGFzIHNjb3BlKCkgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBmdW5jdGlvbiBjbG9zdXJlLlxuICAgKi9cbiAgc3RhcnRTY29wZShuYW1lPzogc3RyaW5nKSB7XG4gICAgY29uc3Qgc2NvcGVJbmZvOiBTY29wZVN0YXRlID0ge1xuICAgICAgdHJhY2s6IFtdLFxuICAgICAgbmFtZTogJ3VubmFtZWQgc2NvcGUnLFxuICAgICAgaWQ6IHRoaXMuc3RhdGUubmV4dFNjb3BlSWQrK1xuICAgIH07XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHNjb3BlSW5mby5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zY29wZVN0YWNrLnB1c2goc2NvcGVJbmZvKTtcbiAgICB0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlID0gc2NvcGVJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBhIHNjb3BlLiBVc2UgdGhpcyB3aXRoIHN0YXJ0U2NvcGUoKSB0byBhY2hpZXZlIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHlcbiAgICogYXMgc2NvcGUoKSB3aXRob3V0IHRoZSBuZWVkIGZvciBhIGZ1bmN0aW9uIGNsb3N1cmUuXG4gICAqL1xuICBlbmRTY29wZShyZXN1bHQ/OiBUZW5zb3JDb250YWluZXIpIHtcbiAgICBjb25zdCB0ZW5zb3JzVG9UcmFja0luUGFyZW50ID0gZ2V0VGVuc29yc0luQ29udGFpbmVyKHJlc3VsdCk7XG4gICAgY29uc3QgdGVuc29yc1RvVHJhY2tJblBhcmVudFNldCA9XG4gICAgICAgIG5ldyBTZXQodGVuc29yc1RvVHJhY2tJblBhcmVudC5tYXAodCA9PiB0LmlkKSk7XG5cbiAgICAvLyBEaXNwb3NlIHRoZSBhcnJheXMgdHJhY2tlZCBpbiB0aGlzIHNjb3BlLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGVuc29yID0gdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFja1tpXTtcbiAgICAgIGlmICghdGVuc29yLmtlcHQgJiYgIXRlbnNvcnNUb1RyYWNrSW5QYXJlbnRTZXQuaGFzKHRlbnNvci5pZCkpIHtcbiAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRTY29wZSA9IHRoaXMuc3RhdGUuc2NvcGVTdGFjay5wb3AoKTtcbiAgICB0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlID0gdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIG51bGwgOlxuICAgICAgICB0aGlzLnN0YXRlLnNjb3BlU3RhY2tbdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gVHJhY2sgdGhlIGN1cnJlbnQgcmVzdWx0IGluIHRoZSBwYXJlbnQgc2NvcGUuXG4gICAgdGVuc29yc1RvVHJhY2tJblBhcmVudC5mb3JFYWNoKHRlbnNvciA9PiB7XG4gICAgICAvLyBPbmx5IHRyYWNrIHRoZSB0ZW5zb3IgaWYgd2FzIGFsbG9jYXRlZCBpbiB0aGUgaW5uZXIgc2NvcGUgYW5kIGlzIG5vdFxuICAgICAgLy8gZ2xvYmFsbHkga2VwdC5cbiAgICAgIGlmICghdGVuc29yLmtlcHQgJiYgdGVuc29yLnNjb3BlSWQgPT09IG9sZFNjb3BlLmlkKSB7XG4gICAgICAgIHRoaXMudHJhY2sodGVuc29yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGdyYWRpZW50cyBvZiBgZmAgd2l0aCByZXNwZWN0IHRvIGVhY2ggb2YgdGhlIGB4c2AuIFRoZSBncmFkaWVudHNcbiAgICogcmV0dXJuZWQgYXJlIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyBgeHNgLCBidXQgc29tZSBtaWdodCBiZSBudWxsIGlmIGBmYFxuICAgKiB3YXMgbm90IGEgZnVuY3Rpb24gb2YgdGhhdCBgeGAuIEl0IGFsc28gdGFrZXMgb3B0aW9uYWwgZHkgdG8gbXVsdGlwbHkgdGhlXG4gICAqIGdyYWRpZW50LCB3aGljaCBkZWZhdWx0cyB0byBgMWAuXG4gICAqL1xuICBncmFkaWVudHM8VCBleHRlbmRzIFRlbnNvcj4oXG4gICAgICBmOiAoKSA9PiBULCB4czogVGVuc29yW10sIGR5PzogVCxcbiAgICAgIGFsbG93Tm9HcmFkaWVudHMgPSBmYWxzZSk6IHt2YWx1ZTogVCwgZ3JhZHM6IFRlbnNvcltdfSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHhzLmxlbmd0aCA+IDAsICgpID0+ICdncmFkaWVudHMoKSByZWNlaXZlZCBhbiBlbXB0eSBsaXN0IG9mIHhzLicpO1xuICAgIGlmIChkeSAhPSBudWxsICYmIGR5LmR0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZHkgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnJHtkeS5kdHlwZX0nYCk7XG4gICAgfVxuXG4gICAgY29uc3QgeSA9IHRoaXMuc2NvcGVkUnVuKFxuICAgICAgICAoKSA9PiB0aGlzLnN0YXJ0VGFwZSgpLCAoKSA9PiB0aGlzLmVuZFRhcGUoKSxcbiAgICAgICAgKCkgPT4gdGhpcy50aWR5KCdmb3J3YXJkJywgZikpO1xuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHkgaW5zdGFuY2VvZiBUZW5zb3IsXG4gICAgICAgICgpID0+ICdUaGUgcmVzdWx0IHkgcmV0dXJuZWQgYnkgZigpIG11c3QgYmUgYSB0ZW5zb3IuJyk7XG4gICAgLy8gRmlsdGVyIG91dCB0aGUgbm9kZXMgdGhhdCBkb24ndCBjb25uZWN0IHggPT4geS5cbiAgICBjb25zdCBmaWx0ZXJlZFRhcGUgPSBnZXRGaWx0ZXJlZE5vZGVzWFRvWSh0aGlzLnN0YXRlLmFjdGl2ZVRhcGUsIHhzLCB5KTtcbiAgICBpZiAoIWFsbG93Tm9HcmFkaWVudHMgJiYgZmlsdGVyZWRUYXBlLmxlbmd0aCA9PT0gMCAmJiB4cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlICcgK1xuICAgICAgICAgICd0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCAnICtcbiAgICAgICAgICAndG8geS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aWR5KCdiYWNrd2FyZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGFjY3VtdWxhdGVkR3JhZGllbnRNYXA6IHtbdGVuc29ySWQ6IG51bWJlcl06IFRlbnNvcn0gPSB7fTtcbiAgICAgIGFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeS5pZF0gPSAoZHkgPT0gbnVsbCkgPyBvbmVzKHkuc2hhcGUpIDogZHk7XG5cbiAgICAgIC8vIEJhY2twcm9wIGdyYWRpZW50cyB0aHJvdWdoIHRoZSBmaWx0ZXJlZCBub2Rlcy5cbiAgICAgIGJhY2twcm9wYWdhdGVHcmFkaWVudHMoXG4gICAgICAgICAgYWNjdW11bGF0ZWRHcmFkaWVudE1hcCwgZmlsdGVyZWRUYXBlLFxuICAgICAgICAgIC8vIFBhc3MgdGhlIHRpZHkgZnVuY3Rpb24gdG8gYXZvaWQgY2lyY3VsYXIgZGVwIHdpdGggYHRhcGUudHNgLlxuICAgICAgICAgIGYgPT4gdGhpcy50aWR5KGYgYXMgU2NvcGVGbjxUZW5zb3I+KSxcbiAgICAgICAgICAvLyBQYXNzIGFuIGFkZCBmdW5jdGlvbiB0byBhdm9pZGUgYSBjaXJjdWxhciBkZXAgd2l0aCBgdGFwZS50c2AuXG4gICAgICAgICAgYWRkKTtcbiAgICAgIGNvbnN0IGdyYWRzID0geHMubWFwKHggPT4gYWNjdW11bGF0ZWRHcmFkaWVudE1hcFt4LmlkXSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3QgY29tcHV0aW5nIGhpZ2hlci1vcmRlciBncmFkaWVudHNcbiAgICAgICAgLy8gYW5kIGNhbiBjbGVhbiB1cCB0aGUgdGFwZS5cbiAgICAgICAgdGhpcy5zdGF0ZS5hY3RpdmVUYXBlLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCB0ZW5zb3Igb2Ygbm9kZS5zYXZlZCkge1xuICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlLmFjdGl2ZVRhcGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt2YWx1ZTogeSwgZ3JhZHN9O1xuICAgIH0pO1xuICB9XG5cbiAgY3VzdG9tR3JhZDxUIGV4dGVuZHMgVGVuc29yPihmOiBDdXN0b21HcmFkaWVudEZ1bmM8VD4pOlxuICAgICAgKC4uLmFyZ3M6IEFycmF5PFRlbnNvcnxHcmFkU2F2ZUZ1bmM+KSA9PiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5pc0Z1bmN0aW9uKGYpLFxuICAgICAgICAoKSA9PiAnVGhlIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIHJldHVybiAoLi4uaW5wdXRzOiBUZW5zb3JbXSk6IFQgPT4ge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgaW5wdXRzLmV2ZXJ5KHQgPT4gdCBpbnN0YW5jZW9mIFRlbnNvciksXG4gICAgICAgICAgKCkgPT4gJ1RoZSBhcmdzIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpKHgxLCB4MiwuLi4pIG11c3QgYWxsIGJlICcgK1xuICAgICAgICAgICAgICAndGVuc29ycycpO1xuXG4gICAgICBsZXQgcmVzOiB7XG4gICAgICAgIHZhbHVlOiBULFxuICAgICAgICBncmFkRnVuYzogKGR5OiBULCBzYXZlZDogVGVuc29yW10pID0+IFRlbnNvciB8IFRlbnNvcltdLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlucHV0TWFwOiBOYW1lZFRlbnNvck1hcCA9IHt9O1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICAgIGlucHV0TWFwW2ldID0gaW5wdXQ7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZm9yd2FyZEZ1bmM6IEZvcndhcmRGdW5jPFQ+ID0gKF8sIHNhdmUpID0+IHtcbiAgICAgICAgcmVzID0gZiguLi5bLi4uaW5wdXRzLCBzYXZlXSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgcmVzLnZhbHVlIGluc3RhbmNlb2YgVGVuc29yLFxuICAgICAgICAgICAgKCkgPT4gJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuICcgK1xuICAgICAgICAgICAgICAgICdvYmplY3Qgd2hlcmUgYG9iai52YWx1ZWAgaXMgYSB0ZW5zb3InKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgICB1dGlsLmlzRnVuY3Rpb24ocmVzLmdyYWRGdW5jKSxcbiAgICAgICAgICAgICgpID0+ICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiAnICtcbiAgICAgICAgICAgICAgICAnb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBiYWNrd2FyZHNGdW5jID0gKGR5OiBULCBzYXZlZDogVGVuc29yW10pID0+IHtcbiAgICAgICAgY29uc3QgZ3JhZFJlcyA9IHJlcy5ncmFkRnVuYyhkeSwgc2F2ZWQpO1xuICAgICAgICBjb25zdCBncmFkczogVGVuc29yW10gPSBBcnJheS5pc0FycmF5KGdyYWRSZXMpID8gZ3JhZFJlcyA6IFtncmFkUmVzXTtcbiAgICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgICBncmFkcy5sZW5ndGggPT09IGlucHV0cy5sZW5ndGgsXG4gICAgICAgICAgICAoKSA9PiAnVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gJyArXG4gICAgICAgICAgICAgICAgJ29iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyAnICtcbiAgICAgICAgICAgICAgICAndGhlIHNhbWUgbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgICAgZ3JhZHMuZXZlcnkodCA9PiB0IGluc3RhbmNlb2YgVGVuc29yKSxcbiAgICAgICAgICAgICgpID0+ICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiAnICtcbiAgICAgICAgICAgICAgICAnb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zICcgK1xuICAgICAgICAgICAgICAgICdhIGxpc3Qgb2Ygb25seSB0ZW5zb3JzLicpO1xuICAgICAgICBjb25zdCBncmFkTWFwOiB7W2tleTogc3RyaW5nXTogKCkgPT4gVGVuc29yfSA9IHt9O1xuICAgICAgICBncmFkcy5mb3JFYWNoKChncmFkLCBpKSA9PiB7XG4gICAgICAgICAgZ3JhZE1hcFtpXSA9ICgpID0+IGdyYWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ3JhZE1hcDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1bktlcm5lbEZ1bmMoe1xuICAgICAgICBmb3J3YXJkRnVuYyxcbiAgICAgICAgYmFja3dhcmRzRnVuYyxcbiAgICAgICAgaW5wdXRzOiBpbnB1dE1hcCxcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICByZWFkU3luYyhkYXRhSWQ6IERhdGFJZCk6IEJhY2tlbmRWYWx1ZXMge1xuICAgIC8vIFJvdXRlIHRoZSByZWFkIHRvIHRoZSBjb3JyZWN0IGJhY2tlbmQuXG4gICAgY29uc3QgaW5mbyA9IHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoZGF0YUlkKTtcbiAgICByZXR1cm4gaW5mby5iYWNrZW5kLnJlYWRTeW5jKGRhdGFJZCk7XG4gIH1cbiAgcmVhZChkYXRhSWQ6IERhdGFJZCk6IFByb21pc2U8QmFja2VuZFZhbHVlcz4ge1xuICAgIC8vIFJvdXRlIHRoZSByZWFkIHRvIHRoZSBjb3JyZWN0IGJhY2tlbmQuXG4gICAgY29uc3QgaW5mbyA9IHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoZGF0YUlkKTtcbiAgICByZXR1cm4gaW5mby5iYWNrZW5kLnJlYWQoZGF0YUlkKTtcbiAgfVxuXG4gIHJlYWRUb0dQVShkYXRhSWQ6IERhdGFJZCwgb3B0aW9ucz86IERhdGFUb0dQVU9wdGlvbnMpOiBHUFVEYXRhIHtcbiAgICAvLyBSb3V0ZSB0aGUgcmVhZCB0byB0aGUgY29ycmVjdCBiYWNrZW5kLlxuICAgIGNvbnN0IGluZm8gPSB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGRhdGFJZCk7XG4gICAgcmV0dXJuIGluZm8uYmFja2VuZC5yZWFkVG9HUFUoZGF0YUlkLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHRpbWUocXVlcnk6ICgpID0+IHZvaWQpOiBQcm9taXNlPFRpbWluZ0luZm8+IHtcbiAgICBjb25zdCBzdGFydCA9IG5vdygpO1xuICAgIGNvbnN0IHRpbWluZ0luZm8gPSBhd2FpdCB0aGlzLmJhY2tlbmQudGltZShxdWVyeSkgYXMgVGltaW5nSW5mbztcbiAgICB0aW1pbmdJbmZvLndhbGxNcyA9IG5vdygpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIHRpbWluZ0luZm87XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIGEgVGVuc29yIGluIHRoZSBjdXJyZW50IHNjb3BlIHRvIGJlIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cFxuICAgKiB3aGVuIHRoZSBjdXJyZW50IHNjb3BlIGVuZHMsIGFuZCByZXR1cm5zIHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHJlc3VsdCBUaGUgVGVuc29yIHRvIHRyYWNrIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKi9cbiAgcHJpdmF0ZSB0cmFjazxUIGV4dGVuZHMgVGVuc29yPihyZXN1bHQ6IFQpOiBUIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5hY3RpdmVTY29wZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQuc2NvcGVJZCA9IHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUuaWQ7XG4gICAgICB0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2gocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0IHJlZ2lzdGVyZWRWYXJpYWJsZXMoKTogTmFtZWRWYXJpYWJsZU1hcCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGVuZ2luZSBzdGF0ZS4gUmVtb3ZlcyBhbGwgYmFja2VuZHMgYnV0IGRvZXMgbm90IHJlbW92ZVxuICAgKiByZWdpc3RlcmVkIGJhY2tlbmQgZmFjdG9yaWVzLlxuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gTWFrZSBhbnkgcGVuZGluZyBwcm9taXNlIG9ic29sZXRlLlxuICAgIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQrKztcblxuICAgIHRoaXMuc3RhdGUuZGlzcG9zZSgpO1xuICAgIHRoaXMuRU5WLnJlc2V0KCk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBFbmdpbmVTdGF0ZSgpO1xuXG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBpbiB0aGlzLnJlZ2lzdHJ5KSB7XG4gICAgICB0aGlzLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyhiYWNrZW5kTmFtZSk7XG4gICAgICB0aGlzLnJlZ2lzdHJ5W2JhY2tlbmROYW1lXS5kaXNwb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5yZWdpc3RyeVtiYWNrZW5kTmFtZV07XG4gICAgfVxuICAgIHRoaXMuYmFja2VuZE5hbWUgPSBudWxsO1xuICAgIHRoaXMuYmFja2VuZEluc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25lcyhzaGFwZTogbnVtYmVyW10pOiBUZW5zb3Ige1xuICBjb25zdCB2YWx1ZXMgPSBtYWtlT25lc1R5cGVkQXJyYXkoc2l6ZUZyb21TaGFwZShzaGFwZSksICdmbG9hdDMyJyk7XG4gIHJldHVybiBFTkdJTkUubWFrZVRlbnNvcih2YWx1ZXMsIHNoYXBlLCAnZmxvYXQzMicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JNYWtlRW5naW5lKCk6IEVuZ2luZSB7XG4gIGNvbnN0IG5zID0gZ2V0R2xvYmFsTmFtZXNwYWNlKCkgYXMge30gYXMge190ZmVuZ2luZTogRW5naW5lfTtcbiAgaWYgKG5zLl90ZmVuZ2luZSA9PSBudWxsKSB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBuZXcgRW52aXJvbm1lbnQobnMpO1xuICAgIG5zLl90ZmVuZ2luZSA9IG5ldyBFbmdpbmUoZW52aXJvbm1lbnQpO1xuICB9XG4gIHNldEVudmlyb25tZW50R2xvYmFsKG5zLl90ZmVuZ2luZS5FTlYpO1xuXG4gIC8vIFRlbGwgdGhlIGN1cnJlbnQgdGVuc29yIGludGVyZmFjZSB0aGF0IHRoZSBnbG9iYWwgZW5naW5lIGlzIHJlc3BvbnNpYmxlXG4gIC8vIGZvciB0cmFja2luZy5cbiAgc2V0VGVuc29yVHJhY2tlcigoKSA9PiBucy5fdGZlbmdpbmUpO1xuICByZXR1cm4gbnMuX3RmZW5naW5lO1xufVxuXG5leHBvcnQgY29uc3QgRU5HSU5FID0gZ2V0T3JNYWtlRW5naW5lKCk7XG5cbi8qKlxuICogQSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWRkIG9wIGZvciB1c2Ugd2l0aGluIGVuZ2luZSBhbmQgdGFwZS5cbiAqXG4gKiBUaGlzIGFsbG93cyB1cyB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBhZGQudHMgYW5kIGVuZ2luZS5cbiAqIEl0IGlzIGV4cG9ydGVkIHRvIGJlIGF2YWlsYWJsZSBpbiB0YXBlIHRlc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGE6IFRlbnNvciwgYjogVGVuc29yKTogVGVuc29yIHtcbiAgLy8gV2UgZHVwbGljYXRlIEFkZCBoZXJlIHRvIGF2b2lkIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIGFkZC50cy5cbiAgY29uc3QgaW5wdXRzID0ge2EsIGJ9O1xuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChBZGQsIGlucHV0cyBhcyB7fSBhcyBOYW1lZFRlbnNvck1hcCk7XG59XG4iXX0=